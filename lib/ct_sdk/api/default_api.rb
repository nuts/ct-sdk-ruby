=begin
#Commercetools

#No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: undefined

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.0.0

=end

require 'cgi'

module CtSdk
  class DefaultApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # @param project_key [String] 
    # @param id [String] 
    # @param order_edit_apply [OrderEditApply] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def apply_order_edit(project_key, id, order_edit_apply, opts = {})
      apply_order_edit_with_http_info(project_key, id, order_edit_apply, opts)
      nil
    end

    # @param project_key [String] 
    # @param id [String] 
    # @param order_edit_apply [OrderEditApply] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def apply_order_edit_with_http_info(project_key, id, order_edit_apply, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.apply_order_edit ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.apply_order_edit"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.apply_order_edit"
      end
      # verify the required parameter 'order_edit_apply' is set
      if @api_client.config.client_side_validation && order_edit_apply.nil?
        fail ArgumentError, "Missing the required parameter 'order_edit_apply' when calling DefaultApi.apply_order_edit"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/edits/{ID}/apply'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_edit_apply)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.apply_order_edit",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#apply_order_edit\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Authenticate Customer (Sign In). Retrieves the authenticated customer (a customer that matches the given email/password pair). If used with an access token for Anonymous Sessions, all orders and carts belonging to the anonymousId will be assigned to the newly created customer. If a cart is is returned as part of the CustomerSignInResult, it has been recalculated (It will have up-to-date prices, taxes and discounts, and invalid line items have been removed.).
    # @param project_key [String] 
    # @param customer_signin [CustomerSignin] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def authenticate_customer__sign_in(project_key, customer_signin, opts = {})
      authenticate_customer__sign_in_with_http_info(project_key, customer_signin, opts)
      nil
    end

    # Authenticate Customer (Sign In). Retrieves the authenticated customer (a customer that matches the given email/password pair). If used with an access token for Anonymous Sessions, all orders and carts belonging to the anonymousId will be assigned to the newly created customer. If a cart is is returned as part of the CustomerSignInResult, it has been recalculated (It will have up-to-date prices, taxes and discounts, and invalid line items have been removed.).
    # @param project_key [String] 
    # @param customer_signin [CustomerSignin] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def authenticate_customer__sign_in_with_http_info(project_key, customer_signin, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.authenticate_customer__sign_in ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.authenticate_customer__sign_in"
      end
      # verify the required parameter 'customer_signin' is set
      if @api_client.config.client_side_validation && customer_signin.nil?
        fail ArgumentError, "Missing the required parameter 'customer_signin' when calling DefaultApi.authenticate_customer__sign_in"
      end
      # resource path
      local_var_path = '/{projectKey}/login'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_signin)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.authenticate_customer__sign_in",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#authenticate_customer__sign_in\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Authenticate Customer (Sign In) in store
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_signin [CustomerSignin] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def authenticate_customer__sign_in_in_store(project_key, store_key, customer_signin, opts = {})
      authenticate_customer__sign_in_in_store_with_http_info(project_key, store_key, customer_signin, opts)
      nil
    end

    # Authenticate Customer (Sign In) in store
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_signin [CustomerSignin] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def authenticate_customer__sign_in_in_store_with_http_info(project_key, store_key, customer_signin, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.authenticate_customer__sign_in_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.authenticate_customer__sign_in_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.authenticate_customer__sign_in_in_store"
      end
      # verify the required parameter 'customer_signin' is set
      if @api_client.config.client_side_validation && customer_signin.nil?
        fail ArgumentError, "Missing the required parameter 'customer_signin' when calling DefaultApi.authenticate_customer__sign_in_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/login'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_signin)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.authenticate_customer__sign_in_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#authenticate_customer__sign_in_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [CustomerSignInResult]
    def authenticate_my_customer__sign_in(project_key, opts = {})
      data, _status_code, _headers = authenticate_my_customer__sign_in_with_http_info(project_key, opts)
      data
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CustomerSignInResult, Integer, Hash)>] CustomerSignInResult data, response status code and response headers
    def authenticate_my_customer__sign_in_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.authenticate_my_customer__sign_in ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.authenticate_my_customer__sign_in"
      end
      # resource path
      local_var_path = '/{projectKey}/me/login'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerSignInResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.authenticate_my_customer__sign_in",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#authenticate_my_customer__sign_in\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Change a customers password
    # @param project_key [String] 
    # @param customer_change_password [CustomerChangePassword] 
    # @param [Hash] opts the optional parameters
    # @return [Customer]
    def change_a_customers_password(project_key, customer_change_password, opts = {})
      data, _status_code, _headers = change_a_customers_password_with_http_info(project_key, customer_change_password, opts)
      data
    end

    # Change a customers password
    # @param project_key [String] 
    # @param customer_change_password [CustomerChangePassword] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def change_a_customers_password_with_http_info(project_key, customer_change_password, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.change_a_customers_password ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.change_a_customers_password"
      end
      # verify the required parameter 'customer_change_password' is set
      if @api_client.config.client_side_validation && customer_change_password.nil?
        fail ArgumentError, "Missing the required parameter 'customer_change_password' when calling DefaultApi.change_a_customers_password"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/password'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_change_password)

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.change_a_customers_password",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#change_a_customers_password\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Change a customers password
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_change_password [CustomerChangePassword] 
    # @param [Hash] opts the optional parameters
    # @return [Customer]
    def change_a_customers_password_in_store(project_key, store_key, customer_change_password, opts = {})
      data, _status_code, _headers = change_a_customers_password_in_store_with_http_info(project_key, store_key, customer_change_password, opts)
      data
    end

    # Change a customers password
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_change_password [CustomerChangePassword] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def change_a_customers_password_in_store_with_http_info(project_key, store_key, customer_change_password, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.change_a_customers_password_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.change_a_customers_password_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.change_a_customers_password_in_store"
      end
      # verify the required parameter 'customer_change_password' is set
      if @api_client.config.client_side_validation && customer_change_password.nil?
        fail ArgumentError, "Missing the required parameter 'customer_change_password' when calling DefaultApi.change_a_customers_password_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/password'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_change_password)

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.change_a_customers_password_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#change_a_customers_password_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [MyCustomer]
    def change_my_customers_password(project_key, opts = {})
      data, _status_code, _headers = change_my_customers_password_with_http_info(project_key, opts)
      data
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MyCustomer, Integer, Hash)>] MyCustomer data, response status code and response headers
    def change_my_customers_password_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.change_my_customers_password ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.change_my_customers_password"
      end
      # resource path
      local_var_path = '/{projectKey}/me/password'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyCustomer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.change_my_customers_password",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#change_my_customers_password\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # The token value is used to reset the password of the customer with the given email. The token is valid only for 10 minutes.
    # @param project_key [String] 
    # @param customer_create_password_reset_token [CustomerCreatePasswordResetToken] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def create_a_token_for_resetting_the_customers_password(project_key, customer_create_password_reset_token, opts = {})
      create_a_token_for_resetting_the_customers_password_with_http_info(project_key, customer_create_password_reset_token, opts)
      nil
    end

    # The token value is used to reset the password of the customer with the given email. The token is valid only for 10 minutes.
    # @param project_key [String] 
    # @param customer_create_password_reset_token [CustomerCreatePasswordResetToken] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_a_token_for_resetting_the_customers_password_with_http_info(project_key, customer_create_password_reset_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_a_token_for_resetting_the_customers_password ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_a_token_for_resetting_the_customers_password"
      end
      # verify the required parameter 'customer_create_password_reset_token' is set
      if @api_client.config.client_side_validation && customer_create_password_reset_token.nil?
        fail ArgumentError, "Missing the required parameter 'customer_create_password_reset_token' when calling DefaultApi.create_a_token_for_resetting_the_customers_password"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/password-token'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_create_password_reset_token)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_a_token_for_resetting_the_customers_password",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_a_token_for_resetting_the_customers_password\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # The token value is used to reset the password of the customer with the given email. The token is valid only for 10 minutes.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_create_password_reset_token [CustomerCreatePasswordResetToken] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def create_a_token_for_resetting_the_customers_password_in_store(project_key, store_key, customer_create_password_reset_token, opts = {})
      create_a_token_for_resetting_the_customers_password_in_store_with_http_info(project_key, store_key, customer_create_password_reset_token, opts)
      nil
    end

    # The token value is used to reset the password of the customer with the given email. The token is valid only for 10 minutes.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_create_password_reset_token [CustomerCreatePasswordResetToken] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_a_token_for_resetting_the_customers_password_in_store_with_http_info(project_key, store_key, customer_create_password_reset_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_a_token_for_resetting_the_customers_password_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_a_token_for_resetting_the_customers_password_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.create_a_token_for_resetting_the_customers_password_in_store"
      end
      # verify the required parameter 'customer_create_password_reset_token' is set
      if @api_client.config.client_side_validation && customer_create_password_reset_token.nil?
        fail ArgumentError, "Missing the required parameter 'customer_create_password_reset_token' when calling DefaultApi.create_a_token_for_resetting_the_customers_password_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/password-token'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_create_password_reset_token)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_a_token_for_resetting_the_customers_password_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_a_token_for_resetting_the_customers_password_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Token for verifying the Customer's Email
    # @param project_key [String] 
    # @param customer_create_email_token [CustomerCreateEmailToken] 
    # @param [Hash] opts the optional parameters
    # @return [CustomerToken]
    def create_a_token_for_verifying_the_customers_email(project_key, customer_create_email_token, opts = {})
      data, _status_code, _headers = create_a_token_for_verifying_the_customers_email_with_http_info(project_key, customer_create_email_token, opts)
      data
    end

    # Create a Token for verifying the Customer&#39;s Email
    # @param project_key [String] 
    # @param customer_create_email_token [CustomerCreateEmailToken] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CustomerToken, Integer, Hash)>] CustomerToken data, response status code and response headers
    def create_a_token_for_verifying_the_customers_email_with_http_info(project_key, customer_create_email_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_a_token_for_verifying_the_customers_email ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_a_token_for_verifying_the_customers_email"
      end
      # verify the required parameter 'customer_create_email_token' is set
      if @api_client.config.client_side_validation && customer_create_email_token.nil?
        fail ArgumentError, "Missing the required parameter 'customer_create_email_token' when calling DefaultApi.create_a_token_for_verifying_the_customers_email"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/email-token'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_create_email_token)

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerToken'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_a_token_for_verifying_the_customers_email",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_a_token_for_verifying_the_customers_email\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Token for verifying the Customer's Email in store
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_create_email_token [CustomerCreateEmailToken] 
    # @param [Hash] opts the optional parameters
    # @return [CustomerToken]
    def create_a_token_for_verifying_the_customers_email_in_store(project_key, store_key, customer_create_email_token, opts = {})
      data, _status_code, _headers = create_a_token_for_verifying_the_customers_email_in_store_with_http_info(project_key, store_key, customer_create_email_token, opts)
      data
    end

    # Create a Token for verifying the Customer&#39;s Email in store
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_create_email_token [CustomerCreateEmailToken] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CustomerToken, Integer, Hash)>] CustomerToken data, response status code and response headers
    def create_a_token_for_verifying_the_customers_email_in_store_with_http_info(project_key, store_key, customer_create_email_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_a_token_for_verifying_the_customers_email_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_a_token_for_verifying_the_customers_email_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.create_a_token_for_verifying_the_customers_email_in_store"
      end
      # verify the required parameter 'customer_create_email_token' is set
      if @api_client.config.client_side_validation && customer_create_email_token.nil?
        fail ArgumentError, "Missing the required parameter 'customer_create_email_token' when calling DefaultApi.create_a_token_for_verifying_the_customers_email_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/email-token'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_create_email_token)

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerToken'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_a_token_for_verifying_the_customers_email_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_a_token_for_verifying_the_customers_email_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create an Order by Import
    # @param project_key [String] 
    # @param order_import_draft [OrderImportDraft] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def create_an_order_by_import(project_key, order_import_draft, opts = {})
      create_an_order_by_import_with_http_info(project_key, order_import_draft, opts)
      nil
    end

    # Create an Order by Import
    # @param project_key [String] 
    # @param order_import_draft [OrderImportDraft] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_an_order_by_import_with_http_info(project_key, order_import_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_an_order_by_import ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_an_order_by_import"
      end
      # verify the required parameter 'order_import_draft' is set
      if @api_client.config.client_side_validation && order_import_draft.nil?
        fail ArgumentError, "Missing the required parameter 'order_import_draft' when calling DefaultApi.create_an_order_by_import"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/import'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_import_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_an_order_by_import",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_an_order_by_import\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create ApiClient
    # @param project_key [String] 
    # @param api_client_draft [ApiClientDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_api_client(project_key, api_client_draft, opts = {})
      create_api_client_with_http_info(project_key, api_client_draft, opts)
      nil
    end

    # Create ApiClient
    # @param project_key [String] 
    # @param api_client_draft [ApiClientDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_api_client_with_http_info(project_key, api_client_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_api_client ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_api_client"
      end
      # verify the required parameter 'api_client_draft' is set
      if @api_client.config.client_side_validation && api_client_draft.nil?
        fail ArgumentError, "Missing the required parameter 'api_client_draft' when calling DefaultApi.create_api_client"
      end
      # resource path
      local_var_path = '/{projectKey}/api-clients'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(api_client_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_api_client",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_api_client\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creating a cart can fail with an InvalidOperation if the referenced shipping method in the CartDraft has a predicate which does not match the cart.
    # @param project_key [String] 
    # @param cart_draft [CartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_cart(project_key, cart_draft, opts = {})
      create_cart_with_http_info(project_key, cart_draft, opts)
      nil
    end

    # Creating a cart can fail with an InvalidOperation if the referenced shipping method in the CartDraft has a predicate which does not match the cart.
    # @param project_key [String] 
    # @param cart_draft [CartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_cart_with_http_info(project_key, cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_cart ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_cart"
      end
      # verify the required parameter 'cart_draft' is set
      if @api_client.config.client_side_validation && cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'cart_draft' when calling DefaultApi.create_cart"
      end
      # resource path
      local_var_path = '/{projectKey}/carts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_cart",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_cart\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create CartDiscount
    # @param project_key [String] 
    # @param cart_discount_draft [CartDiscountDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_cart_discount(project_key, cart_discount_draft, opts = {})
      create_cart_discount_with_http_info(project_key, cart_discount_draft, opts)
      nil
    end

    # Create CartDiscount
    # @param project_key [String] 
    # @param cart_discount_draft [CartDiscountDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_cart_discount_with_http_info(project_key, cart_discount_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_cart_discount ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_cart_discount"
      end
      # verify the required parameter 'cart_discount_draft' is set
      if @api_client.config.client_side_validation && cart_discount_draft.nil?
        fail ArgumentError, "Missing the required parameter 'cart_discount_draft' when calling DefaultApi.create_cart_discount"
      end
      # resource path
      local_var_path = '/{projectKey}/cart-discounts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_discount_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_cart_discount",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_cart_discount\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creates a cart in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store's key. When using this endpoint the cart's store field is always set to the store specified in the path parameter. Creating a cart can fail with an InvalidOperation if the referenced shipping method in the CartDraft has a predicate which does not match the cart.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param cart_draft [CartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_cart_in_store(project_key, store_key, cart_draft, opts = {})
      create_cart_in_store_with_http_info(project_key, store_key, cart_draft, opts)
      nil
    end

    # Creates a cart in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store&#39;s key. When using this endpoint the cart&#39;s store field is always set to the store specified in the path parameter. Creating a cart can fail with an InvalidOperation if the referenced shipping method in the CartDraft has a predicate which does not match the cart.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param cart_draft [CartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_cart_in_store_with_http_info(project_key, store_key, cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_cart_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_cart_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.create_cart_in_store"
      end
      # verify the required parameter 'cart_draft' is set
      if @api_client.config.client_side_validation && cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'cart_draft' when calling DefaultApi.create_cart_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_cart_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_cart_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creating a category produces the CategoryCreated message.
    # @param project_key [String] 
    # @param category_draft [CategoryDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_category(project_key, category_draft, opts = {})
      create_category_with_http_info(project_key, category_draft, opts)
      nil
    end

    # Creating a category produces the CategoryCreated message.
    # @param project_key [String] 
    # @param category_draft [CategoryDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_category_with_http_info(project_key, category_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_category ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_category"
      end
      # verify the required parameter 'category_draft' is set
      if @api_client.config.client_side_validation && category_draft.nil?
        fail ArgumentError, "Missing the required parameter 'category_draft' when calling DefaultApi.create_category"
      end
      # resource path
      local_var_path = '/{projectKey}/categories'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(category_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_category",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_category\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Channel
    # @param project_key [String] 
    # @param channel_draft [ChannelDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_channel(project_key, channel_draft, opts = {})
      create_channel_with_http_info(project_key, channel_draft, opts)
      nil
    end

    # Create Channel
    # @param project_key [String] 
    # @param channel_draft [ChannelDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_channel_with_http_info(project_key, channel_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_channel ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_channel"
      end
      # verify the required parameter 'channel_draft' is set
      if @api_client.config.client_side_validation && channel_draft.nil?
        fail ArgumentError, "Missing the required parameter 'channel_draft' when calling DefaultApi.create_channel"
      end
      # resource path
      local_var_path = '/{projectKey}/channels'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(channel_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_channel",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_channel\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creates a new custom object or updates an existing custom object. If an object with the given container/key exists, the object will be replaced with the new value and the version is incremented. If the request contains a version and an object with the given container/key exists then the version must match the version of the existing object. Concurrent updates for the same custom object still can result in a Conflict (409) even if the version is not provided. Fields with null values will not be saved.
    # @param project_key [String] 
    # @param custom_object_draft [CustomObjectDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_custom_object(project_key, custom_object_draft, opts = {})
      create_custom_object_with_http_info(project_key, custom_object_draft, opts)
      nil
    end

    # Creates a new custom object or updates an existing custom object. If an object with the given container/key exists, the object will be replaced with the new value and the version is incremented. If the request contains a version and an object with the given container/key exists then the version must match the version of the existing object. Concurrent updates for the same custom object still can result in a Conflict (409) even if the version is not provided. Fields with null values will not be saved.
    # @param project_key [String] 
    # @param custom_object_draft [CustomObjectDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_custom_object_with_http_info(project_key, custom_object_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_custom_object ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_custom_object"
      end
      # verify the required parameter 'custom_object_draft' is set
      if @api_client.config.client_side_validation && custom_object_draft.nil?
        fail ArgumentError, "Missing the required parameter 'custom_object_draft' when calling DefaultApi.create_custom_object"
      end
      # resource path
      local_var_path = '/{projectKey}/custom-objects'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(custom_object_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_custom_object",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_custom_object\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creates a customer. If an anonymous cart is passed in, then the cart is assigned to the created customer and the version number of the Cart will increase. If the ID of an anonymous session is given, all carts and orders will be assigned to the created customer.
    # @param project_key [String] 
    # @param customer_draft [CustomerDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_customer(project_key, customer_draft, opts = {})
      create_customer_with_http_info(project_key, customer_draft, opts)
      nil
    end

    # Creates a customer. If an anonymous cart is passed in, then the cart is assigned to the created customer and the version number of the Cart will increase. If the ID of an anonymous session is given, all carts and orders will be assigned to the created customer.
    # @param project_key [String] 
    # @param customer_draft [CustomerDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_customer_with_http_info(project_key, customer_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_customer ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_customer"
      end
      # verify the required parameter 'customer_draft' is set
      if @api_client.config.client_side_validation && customer_draft.nil?
        fail ArgumentError, "Missing the required parameter 'customer_draft' when calling DefaultApi.create_customer"
      end
      # resource path
      local_var_path = '/{projectKey}/customers'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_customer",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create CustomerGroup
    # @param project_key [String] 
    # @param customer_group_draft [CustomerGroupDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_customer_group(project_key, customer_group_draft, opts = {})
      create_customer_group_with_http_info(project_key, customer_group_draft, opts)
      nil
    end

    # Create CustomerGroup
    # @param project_key [String] 
    # @param customer_group_draft [CustomerGroupDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_customer_group_with_http_info(project_key, customer_group_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_customer_group ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_customer_group"
      end
      # verify the required parameter 'customer_group_draft' is set
      if @api_client.config.client_side_validation && customer_group_draft.nil?
        fail ArgumentError, "Missing the required parameter 'customer_group_draft' when calling DefaultApi.create_customer_group"
      end
      # resource path
      local_var_path = '/{projectKey}/customer-groups'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_group_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_customer_group",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_customer_group\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creates a customer in a specific Store. The {storeKey} path parameter maps to a Store's key. When using this endpoint, if omitted, the customer's stores field is set to the store specified in the path parameter. If an anonymous cart is passed in as when using this method, then the cart is assigned to the created customer and the version number of the Cart increases. If the ID of an anonymous session is given, all carts and orders will be assigned to the created customer and the store specified. If you pass in a cart with a store field specified, the store field must reference the same store specified in the {storeKey} path parameter.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_draft [CustomerDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_customer_in_store(project_key, store_key, customer_draft, opts = {})
      create_customer_in_store_with_http_info(project_key, store_key, customer_draft, opts)
      nil
    end

    # Creates a customer in a specific Store. The {storeKey} path parameter maps to a Store&#39;s key. When using this endpoint, if omitted, the customer&#39;s stores field is set to the store specified in the path parameter. If an anonymous cart is passed in as when using this method, then the cart is assigned to the created customer and the version number of the Cart increases. If the ID of an anonymous session is given, all carts and orders will be assigned to the created customer and the store specified. If you pass in a cart with a store field specified, the store field must reference the same store specified in the {storeKey} path parameter.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_draft [CustomerDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_customer_in_store_with_http_info(project_key, store_key, customer_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_customer_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_customer_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.create_customer_in_store"
      end
      # verify the required parameter 'customer_draft' is set
      if @api_client.config.client_side_validation && customer_draft.nil?
        fail ArgumentError, "Missing the required parameter 'customer_draft' when calling DefaultApi.create_customer_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_customer_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_customer_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create DiscountCode
    # @param project_key [String] 
    # @param discount_code_draft [DiscountCodeDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_discount_code(project_key, discount_code_draft, opts = {})
      create_discount_code_with_http_info(project_key, discount_code_draft, opts)
      nil
    end

    # Create DiscountCode
    # @param project_key [String] 
    # @param discount_code_draft [DiscountCodeDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_discount_code_with_http_info(project_key, discount_code_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_discount_code ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_discount_code"
      end
      # verify the required parameter 'discount_code_draft' is set
      if @api_client.config.client_side_validation && discount_code_draft.nil?
        fail ArgumentError, "Missing the required parameter 'discount_code_draft' when calling DefaultApi.create_discount_code"
      end
      # resource path
      local_var_path = '/{projectKey}/discount-codes'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(discount_code_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_discount_code",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_discount_code\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Currently, a maximum of 25 extensions can be created per project.
    # @param project_key [String] 
    # @param extension_draft [ExtensionDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_extension(project_key, extension_draft, opts = {})
      create_extension_with_http_info(project_key, extension_draft, opts)
      nil
    end

    # Currently, a maximum of 25 extensions can be created per project.
    # @param project_key [String] 
    # @param extension_draft [ExtensionDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_extension_with_http_info(project_key, extension_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_extension ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_extension"
      end
      # verify the required parameter 'extension_draft' is set
      if @api_client.config.client_side_validation && extension_draft.nil?
        fail ArgumentError, "Missing the required parameter 'extension_draft' when calling DefaultApi.create_extension"
      end
      # resource path
      local_var_path = '/{projectKey}/extensions'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(extension_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_extension",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_extension\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create InventoryEntry
    # @param project_key [String] 
    # @param inventory_entry_draft [InventoryEntryDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_inventory_entry(project_key, inventory_entry_draft, opts = {})
      create_inventory_entry_with_http_info(project_key, inventory_entry_draft, opts)
      nil
    end

    # Create InventoryEntry
    # @param project_key [String] 
    # @param inventory_entry_draft [InventoryEntryDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_inventory_entry_with_http_info(project_key, inventory_entry_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_inventory_entry ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_inventory_entry"
      end
      # verify the required parameter 'inventory_entry_draft' is set
      if @api_client.config.client_side_validation && inventory_entry_draft.nil?
        fail ArgumentError, "Missing the required parameter 'inventory_entry_draft' when calling DefaultApi.create_inventory_entry"
      end
      # resource path
      local_var_path = '/{projectKey}/inventory'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(inventory_entry_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_inventory_entry",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_inventory_entry\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create MyCart
    # @param project_key [String] 
    # @param my_cart_draft [MyCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_my_cart(project_key, my_cart_draft, opts = {})
      create_my_cart_with_http_info(project_key, my_cart_draft, opts)
      nil
    end

    # Create MyCart
    # @param project_key [String] 
    # @param my_cart_draft [MyCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_my_cart_with_http_info(project_key, my_cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_my_cart ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_my_cart"
      end
      # verify the required parameter 'my_cart_draft' is set
      if @api_client.config.client_side_validation && my_cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'my_cart_draft' when calling DefaultApi.create_my_cart"
      end
      # resource path
      local_var_path = '/{projectKey}/me/carts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_my_cart",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_my_cart\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Cart
    # @param project_key [String] 
    # @param store_key [String] 
    # @param my_cart_draft [MyCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_my_cart_in_store(project_key, store_key, my_cart_draft, opts = {})
      create_my_cart_in_store_with_http_info(project_key, store_key, my_cart_draft, opts)
      nil
    end

    # Create Cart
    # @param project_key [String] 
    # @param store_key [String] 
    # @param my_cart_draft [MyCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_my_cart_in_store_with_http_info(project_key, store_key, my_cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_my_cart_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_my_cart_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.create_my_cart_in_store"
      end
      # verify the required parameter 'my_cart_draft' is set
      if @api_client.config.client_side_validation && my_cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'my_cart_draft' when calling DefaultApi.create_my_cart_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/carts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_my_cart_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_my_cart_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create MyOrder
    # @param project_key [String] 
    # @param my_order_from_cart_draft [MyOrderFromCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_my_order(project_key, my_order_from_cart_draft, opts = {})
      create_my_order_with_http_info(project_key, my_order_from_cart_draft, opts)
      nil
    end

    # Create MyOrder
    # @param project_key [String] 
    # @param my_order_from_cart_draft [MyOrderFromCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_my_order_with_http_info(project_key, my_order_from_cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_my_order ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_my_order"
      end
      # verify the required parameter 'my_order_from_cart_draft' is set
      if @api_client.config.client_side_validation && my_order_from_cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'my_order_from_cart_draft' when calling DefaultApi.create_my_order"
      end
      # resource path
      local_var_path = '/{projectKey}/me/orders'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_order_from_cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_my_order",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_my_order\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Order
    # @param project_key [String] 
    # @param store_key [String] 
    # @param my_order_from_cart_draft [MyOrderFromCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_my_order_in_store(project_key, store_key, my_order_from_cart_draft, opts = {})
      create_my_order_in_store_with_http_info(project_key, store_key, my_order_from_cart_draft, opts)
      nil
    end

    # Create Order
    # @param project_key [String] 
    # @param store_key [String] 
    # @param my_order_from_cart_draft [MyOrderFromCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_my_order_in_store_with_http_info(project_key, store_key, my_order_from_cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_my_order_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_my_order_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.create_my_order_in_store"
      end
      # verify the required parameter 'my_order_from_cart_draft' is set
      if @api_client.config.client_side_validation && my_order_from_cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'my_order_from_cart_draft' when calling DefaultApi.create_my_order_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/orders'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_order_from_cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_my_order_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_my_order_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create MyPayment
    # @param project_key [String] 
    # @param my_payment_draft [MyPaymentDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_my_payment(project_key, my_payment_draft, opts = {})
      create_my_payment_with_http_info(project_key, my_payment_draft, opts)
      nil
    end

    # Create MyPayment
    # @param project_key [String] 
    # @param my_payment_draft [MyPaymentDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_my_payment_with_http_info(project_key, my_payment_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_my_payment ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_my_payment"
      end
      # verify the required parameter 'my_payment_draft' is set
      if @api_client.config.client_side_validation && my_payment_draft.nil?
        fail ArgumentError, "Missing the required parameter 'my_payment_draft' when calling DefaultApi.create_my_payment"
      end
      # resource path
      local_var_path = '/{projectKey}/me/payments'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_payment_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_my_payment",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_my_payment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create MyShoppingList
    # @param project_key [String] 
    # @param my_shopping_list_draft [MyShoppingListDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_my_shopping_list(project_key, my_shopping_list_draft, opts = {})
      create_my_shopping_list_with_http_info(project_key, my_shopping_list_draft, opts)
      nil
    end

    # Create MyShoppingList
    # @param project_key [String] 
    # @param my_shopping_list_draft [MyShoppingListDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_my_shopping_list_with_http_info(project_key, my_shopping_list_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_my_shopping_list ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_my_shopping_list"
      end
      # verify the required parameter 'my_shopping_list_draft' is set
      if @api_client.config.client_side_validation && my_shopping_list_draft.nil?
        fail ArgumentError, "Missing the required parameter 'my_shopping_list_draft' when calling DefaultApi.create_my_shopping_list"
      end
      # resource path
      local_var_path = '/{projectKey}/me/shopping-lists'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_shopping_list_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_my_shopping_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_my_shopping_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creates an order from a Cart. The cart must have a shipping address set before creating an order. When using the Platform TaxMode, the shipping address is used for tax calculation.
    # @param project_key [String] 
    # @param order_from_cart_draft [OrderFromCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_order(project_key, order_from_cart_draft, opts = {})
      create_order_with_http_info(project_key, order_from_cart_draft, opts)
      nil
    end

    # Creates an order from a Cart. The cart must have a shipping address set before creating an order. When using the Platform TaxMode, the shipping address is used for tax calculation.
    # @param project_key [String] 
    # @param order_from_cart_draft [OrderFromCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_order_with_http_info(project_key, order_from_cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_order ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_order"
      end
      # verify the required parameter 'order_from_cart_draft' is set
      if @api_client.config.client_side_validation && order_from_cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'order_from_cart_draft' when calling DefaultApi.create_order"
      end
      # resource path
      local_var_path = '/{projectKey}/orders'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_from_cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_order",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_order\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create OrderEdit
    # @param project_key [String] 
    # @param order_edit_draft [OrderEditDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_order_edit(project_key, order_edit_draft, opts = {})
      create_order_edit_with_http_info(project_key, order_edit_draft, opts)
      nil
    end

    # Create OrderEdit
    # @param project_key [String] 
    # @param order_edit_draft [OrderEditDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_order_edit_with_http_info(project_key, order_edit_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_order_edit ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_order_edit"
      end
      # verify the required parameter 'order_edit_draft' is set
      if @api_client.config.client_side_validation && order_edit_draft.nil?
        fail ArgumentError, "Missing the required parameter 'order_edit_draft' when calling DefaultApi.create_order_edit"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/edits'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_edit_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_order_edit",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_order_edit\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Creates an order from a Cart from a specific Store. The {storeKey} path parameter maps to a Store's key. When using this endpoint the orders's store field is always set to the store specified in the path parameter. The cart must have a shipping address set before creating an order. When using the Platform TaxMode, the shipping address is used for tax calculation.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param order_from_cart_draft [OrderFromCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_order_in_store(project_key, store_key, order_from_cart_draft, opts = {})
      create_order_in_store_with_http_info(project_key, store_key, order_from_cart_draft, opts)
      nil
    end

    # Creates an order from a Cart from a specific Store. The {storeKey} path parameter maps to a Store&#39;s key. When using this endpoint the orders&#39;s store field is always set to the store specified in the path parameter. The cart must have a shipping address set before creating an order. When using the Platform TaxMode, the shipping address is used for tax calculation.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param order_from_cart_draft [OrderFromCartDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_order_in_store_with_http_info(project_key, store_key, order_from_cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_order_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_order_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.create_order_in_store"
      end
      # verify the required parameter 'order_from_cart_draft' is set
      if @api_client.config.client_side_validation && order_from_cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'order_from_cart_draft' when calling DefaultApi.create_order_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/orders'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_from_cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_order_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_order_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # To create a payment object a payment draft object has to be given with the request.
    # @param project_key [String] 
    # @param payment_draft [PaymentDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_payment(project_key, payment_draft, opts = {})
      create_payment_with_http_info(project_key, payment_draft, opts)
      nil
    end

    # To create a payment object a payment draft object has to be given with the request.
    # @param project_key [String] 
    # @param payment_draft [PaymentDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_payment_with_http_info(project_key, payment_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_payment ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_payment"
      end
      # verify the required parameter 'payment_draft' is set
      if @api_client.config.client_side_validation && payment_draft.nil?
        fail ArgumentError, "Missing the required parameter 'payment_draft' when calling DefaultApi.create_payment"
      end
      # resource path
      local_var_path = '/{projectKey}/payments'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(payment_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_payment",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_payment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # To create a new product, send a representation that is going to become the initial staged representation of the new product in the master catalog. If price selection query parameters are provided, the selected prices will be added to the response.
    # @param project_key [String] 
    # @param product_draft [ProductDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_product(project_key, product_draft, opts = {})
      create_product_with_http_info(project_key, product_draft, opts)
      nil
    end

    # To create a new product, send a representation that is going to become the initial staged representation of the new product in the master catalog. If price selection query parameters are provided, the selected prices will be added to the response.
    # @param project_key [String] 
    # @param product_draft [ProductDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_product_with_http_info(project_key, product_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_product ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_product"
      end
      # verify the required parameter 'product_draft' is set
      if @api_client.config.client_side_validation && product_draft.nil?
        fail ArgumentError, "Missing the required parameter 'product_draft' when calling DefaultApi.create_product"
      end
      # resource path
      local_var_path = '/{projectKey}/products'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_product",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_product\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create ProductDiscount
    # @param project_key [String] 
    # @param product_discount_draft [ProductDiscountDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_product_discount(project_key, product_discount_draft, opts = {})
      create_product_discount_with_http_info(project_key, product_discount_draft, opts)
      nil
    end

    # Create ProductDiscount
    # @param project_key [String] 
    # @param product_discount_draft [ProductDiscountDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_product_discount_with_http_info(project_key, product_discount_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_product_discount ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_product_discount"
      end
      # verify the required parameter 'product_discount_draft' is set
      if @api_client.config.client_side_validation && product_discount_draft.nil?
        fail ArgumentError, "Missing the required parameter 'product_discount_draft' when calling DefaultApi.create_product_discount"
      end
      # resource path
      local_var_path = '/{projectKey}/product-discounts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_discount_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_product_discount",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_product_discount\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create ProductType
    # @param project_key [String] 
    # @param product_type_draft [ProductTypeDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_product_type(project_key, product_type_draft, opts = {})
      create_product_type_with_http_info(project_key, product_type_draft, opts)
      nil
    end

    # Create ProductType
    # @param project_key [String] 
    # @param product_type_draft [ProductTypeDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_product_type_with_http_info(project_key, product_type_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_product_type ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_product_type"
      end
      # verify the required parameter 'product_type_draft' is set
      if @api_client.config.client_side_validation && product_type_draft.nil?
        fail ArgumentError, "Missing the required parameter 'product_type_draft' when calling DefaultApi.create_product_type"
      end
      # resource path
      local_var_path = '/{projectKey}/product-types'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_type_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_product_type",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_product_type\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Review
    # @param project_key [String] 
    # @param review_draft [ReviewDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_review(project_key, review_draft, opts = {})
      create_review_with_http_info(project_key, review_draft, opts)
      nil
    end

    # Create Review
    # @param project_key [String] 
    # @param review_draft [ReviewDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_review_with_http_info(project_key, review_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_review ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_review"
      end
      # verify the required parameter 'review_draft' is set
      if @api_client.config.client_side_validation && review_draft.nil?
        fail ArgumentError, "Missing the required parameter 'review_draft' when calling DefaultApi.create_review"
      end
      # resource path
      local_var_path = '/{projectKey}/reviews'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(review_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_review",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_review\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create ShippingMethod
    # @param project_key [String] 
    # @param shipping_method_draft [ShippingMethodDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_shipping_method(project_key, shipping_method_draft, opts = {})
      create_shipping_method_with_http_info(project_key, shipping_method_draft, opts)
      nil
    end

    # Create ShippingMethod
    # @param project_key [String] 
    # @param shipping_method_draft [ShippingMethodDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_shipping_method_with_http_info(project_key, shipping_method_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_shipping_method ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_shipping_method"
      end
      # verify the required parameter 'shipping_method_draft' is set
      if @api_client.config.client_side_validation && shipping_method_draft.nil?
        fail ArgumentError, "Missing the required parameter 'shipping_method_draft' when calling DefaultApi.create_shipping_method"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(shipping_method_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_shipping_method",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_shipping_method\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create ShoppingList
    # @param project_key [String] 
    # @param shopping_list_draft [ShoppingListDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_shopping_list(project_key, shopping_list_draft, opts = {})
      create_shopping_list_with_http_info(project_key, shopping_list_draft, opts)
      nil
    end

    # Create ShoppingList
    # @param project_key [String] 
    # @param shopping_list_draft [ShoppingListDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_shopping_list_with_http_info(project_key, shopping_list_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_shopping_list ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_shopping_list"
      end
      # verify the required parameter 'shopping_list_draft' is set
      if @api_client.config.client_side_validation && shopping_list_draft.nil?
        fail ArgumentError, "Missing the required parameter 'shopping_list_draft' when calling DefaultApi.create_shopping_list"
      end
      # resource path
      local_var_path = '/{projectKey}/shopping-lists'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(shopping_list_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_shopping_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_shopping_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create State
    # @param project_key [String] 
    # @param state_draft [StateDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_state(project_key, state_draft, opts = {})
      create_state_with_http_info(project_key, state_draft, opts)
      nil
    end

    # Create State
    # @param project_key [String] 
    # @param state_draft [StateDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_state_with_http_info(project_key, state_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_state ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_state"
      end
      # verify the required parameter 'state_draft' is set
      if @api_client.config.client_side_validation && state_draft.nil?
        fail ArgumentError, "Missing the required parameter 'state_draft' when calling DefaultApi.create_state"
      end
      # resource path
      local_var_path = '/{projectKey}/states'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(state_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_state",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_state\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Store
    # @param project_key [String] 
    # @param store_draft [StoreDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_store(project_key, store_draft, opts = {})
      create_store_with_http_info(project_key, store_draft, opts)
      nil
    end

    # Create Store
    # @param project_key [String] 
    # @param store_draft [StoreDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_store_with_http_info(project_key, store_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_store"
      end
      # verify the required parameter 'store_draft' is set
      if @api_client.config.client_side_validation && store_draft.nil?
        fail ArgumentError, "Missing the required parameter 'store_draft' when calling DefaultApi.create_store"
      end
      # resource path
      local_var_path = '/{projectKey}/stores'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(store_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # The creation of a Subscription is eventually consistent, it may take up to a minute before it becomes fully active. In order to test that the destination is correctly configured, a test message will be put into the queue. If the message could not be delivered, the subscription will not be created. The payload of the test message is a notification of type ResourceCreated for the resourceTypeId subscription. Currently, a maximum of 25 subscriptions can be created per project.
    # @param project_key [String] 
    # @param subscription_draft [SubscriptionDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_subscription(project_key, subscription_draft, opts = {})
      create_subscription_with_http_info(project_key, subscription_draft, opts)
      nil
    end

    # The creation of a Subscription is eventually consistent, it may take up to a minute before it becomes fully active. In order to test that the destination is correctly configured, a test message will be put into the queue. If the message could not be delivered, the subscription will not be created. The payload of the test message is a notification of type ResourceCreated for the resourceTypeId subscription. Currently, a maximum of 25 subscriptions can be created per project.
    # @param project_key [String] 
    # @param subscription_draft [SubscriptionDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_subscription_with_http_info(project_key, subscription_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_subscription ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_subscription"
      end
      # verify the required parameter 'subscription_draft' is set
      if @api_client.config.client_side_validation && subscription_draft.nil?
        fail ArgumentError, "Missing the required parameter 'subscription_draft' when calling DefaultApi.create_subscription"
      end
      # resource path
      local_var_path = '/{projectKey}/subscriptions'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(subscription_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_subscription",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_subscription\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create TaxCategory
    # @param project_key [String] 
    # @param tax_category_draft [TaxCategoryDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_tax_category(project_key, tax_category_draft, opts = {})
      create_tax_category_with_http_info(project_key, tax_category_draft, opts)
      nil
    end

    # Create TaxCategory
    # @param project_key [String] 
    # @param tax_category_draft [TaxCategoryDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_tax_category_with_http_info(project_key, tax_category_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_tax_category ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_tax_category"
      end
      # verify the required parameter 'tax_category_draft' is set
      if @api_client.config.client_side_validation && tax_category_draft.nil?
        fail ArgumentError, "Missing the required parameter 'tax_category_draft' when calling DefaultApi.create_tax_category"
      end
      # resource path
      local_var_path = '/{projectKey}/tax-categories'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(tax_category_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_tax_category",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_tax_category\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Type
    # @param project_key [String] 
    # @param type_draft [TypeDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_type(project_key, type_draft, opts = {})
      create_type_with_http_info(project_key, type_draft, opts)
      nil
    end

    # Create Type
    # @param project_key [String] 
    # @param type_draft [TypeDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_type_with_http_info(project_key, type_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_type ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_type"
      end
      # verify the required parameter 'type_draft' is set
      if @api_client.config.client_side_validation && type_draft.nil?
        fail ArgumentError, "Missing the required parameter 'type_draft' when calling DefaultApi.create_type"
      end
      # resource path
      local_var_path = '/{projectKey}/types'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(type_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_type",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_type\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Zone
    # @param project_key [String] 
    # @param zone_draft [ZoneDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [nil]
    def create_zone(project_key, zone_draft, opts = {})
      create_zone_with_http_info(project_key, zone_draft, opts)
      nil
    end

    # Create Zone
    # @param project_key [String] 
    # @param zone_draft [ZoneDraft] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_zone_with_http_info(project_key, zone_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_zone ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.create_zone"
      end
      # verify the required parameter 'zone_draft' is set
      if @api_client.config.client_side_validation && zone_draft.nil?
        fail ArgumentError, "Missing the required parameter 'zone_draft' when calling DefaultApi.create_zone"
      end
      # resource path
      local_var_path = '/{projectKey}/zones'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(zone_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.create_zone",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_zone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ApiClient by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiClient]
    def delete_api_client_by_id(project_key, id, opts = {})
      data, _status_code, _headers = delete_api_client_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Delete ApiClient by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiClient, Integer, Hash)>] ApiClient data, response status code and response headers
    def delete_api_client_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_api_client_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_api_client_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_api_client_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/api-clients/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiClient'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_api_client_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_api_client_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Cart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def delete_cart_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_cart_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Cart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def delete_cart_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_cart_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_cart_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_cart_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_cart_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_cart_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_cart_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Cart by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def delete_cart_by_id_in_store(project_key, store_key, id, version, opts = {})
      data, _status_code, _headers = delete_cart_by_id_in_store_with_http_info(project_key, store_key, id, version, opts)
      data
    end

    # Delete Cart by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def delete_cart_by_id_in_store_with_http_info(project_key, store_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_cart_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_cart_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.delete_cart_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_cart_by_id_in_store"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_cart_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_cart_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_cart_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Cart by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def delete_cart_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_cart_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Cart by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def delete_cart_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_cart_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_cart_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_cart_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_cart_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/carts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_cart_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_cart_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Cart by key
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def delete_cart_by_key_in_store(project_key, store_key, key, version, opts = {})
      data, _status_code, _headers = delete_cart_by_key_in_store_with_http_info(project_key, store_key, key, version, opts)
      data
    end

    # Delete Cart by key
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def delete_cart_by_key_in_store_with_http_info(project_key, store_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_cart_by_key_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_cart_by_key_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.delete_cart_by_key_in_store"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_cart_by_key_in_store"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_cart_by_key_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_cart_by_key_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_cart_by_key_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete CartDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CartDiscount]
    def delete_cart_discount_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_cart_discount_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete CartDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CartDiscount, Integer, Hash)>] CartDiscount data, response status code and response headers
    def delete_cart_discount_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_cart_discount_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_cart_discount_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_cart_discount_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_cart_discount_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/cart-discounts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CartDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_cart_discount_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_cart_discount_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete CartDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CartDiscount]
    def delete_cart_discount_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_cart_discount_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete CartDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CartDiscount, Integer, Hash)>] CartDiscount data, response status code and response headers
    def delete_cart_discount_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_cart_discount_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_cart_discount_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_cart_discount_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_cart_discount_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/cart-discounts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CartDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_cart_discount_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_cart_discount_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Category by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Category]
    def delete_category_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_category_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Category by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Category, Integer, Hash)>] Category data, response status code and response headers
    def delete_category_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_category_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_category_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_category_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_category_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/categories/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Category'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_category_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_category_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Category by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Category]
    def delete_category_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_category_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Category by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Category, Integer, Hash)>] Category data, response status code and response headers
    def delete_category_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_category_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_category_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_category_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_category_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/categories/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Category'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_category_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_category_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Channel by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Channel]
    def delete_channel_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_channel_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Channel by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Channel, Integer, Hash)>] Channel data, response status code and response headers
    def delete_channel_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_channel_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_channel_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_channel_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_channel_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/channels/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Channel'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_channel_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_channel_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete CustomObject by container and key
    # @param project_key [String] 
    # @param container [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :version Last seen version of the resource
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [CustomObject]
    def delete_custom_object_by_container_and_key(project_key, container, key, opts = {})
      data, _status_code, _headers = delete_custom_object_by_container_and_key_with_http_info(project_key, container, key, opts)
      data
    end

    # Delete CustomObject by container and key
    # @param project_key [String] 
    # @param container [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :version Last seen version of the resource
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomObject, Integer, Hash)>] CustomObject data, response status code and response headers
    def delete_custom_object_by_container_and_key_with_http_info(project_key, container, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_custom_object_by_container_and_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_custom_object_by_container_and_key"
      end
      # verify the required parameter 'container' is set
      if @api_client.config.client_side_validation && container.nil?
        fail ArgumentError, "Missing the required parameter 'container' when calling DefaultApi.delete_custom_object_by_container_and_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_custom_object_by_container_and_key"
      end
      # resource path
      local_var_path = '/{projectKey}/custom-objects/{container}/{key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'container' + '}', CGI.escape(container.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = opts[:'version'] if !opts[:'version'].nil?
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomObject'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_custom_object_by_container_and_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_custom_object_by_container_and_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Customer by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def delete_customer_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_customer_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Customer by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def delete_customer_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_customer_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_customer_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_customer_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_customer_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_customer_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_customer_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Customer by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def delete_customer_by_id_in_store(project_key, store_key, id, version, opts = {})
      data, _status_code, _headers = delete_customer_by_id_in_store_with_http_info(project_key, store_key, id, version, opts)
      data
    end

    # Delete Customer by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def delete_customer_by_id_in_store_with_http_info(project_key, store_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_customer_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_customer_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.delete_customer_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_customer_by_id_in_store"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_customer_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_customer_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_customer_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Customer by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def delete_customer_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_customer_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Customer by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def delete_customer_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_customer_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_customer_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_customer_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_customer_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_customer_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_customer_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Customer by key
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def delete_customer_by_key_in_store(project_key, store_key, key, version, opts = {})
      data, _status_code, _headers = delete_customer_by_key_in_store_with_http_info(project_key, store_key, key, version, opts)
      data
    end

    # Delete Customer by key
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def delete_customer_by_key_in_store_with_http_info(project_key, store_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_customer_by_key_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_customer_by_key_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.delete_customer_by_key_in_store"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_customer_by_key_in_store"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_customer_by_key_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_customer_by_key_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_customer_by_key_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete CustomerGroup by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CustomerGroup]
    def delete_customer_group_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_customer_group_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete CustomerGroup by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomerGroup, Integer, Hash)>] CustomerGroup data, response status code and response headers
    def delete_customer_group_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_customer_group_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_customer_group_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_customer_group_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_customer_group_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/customer-groups/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_customer_group_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_customer_group_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete CustomerGroup by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CustomerGroup]
    def delete_customer_group_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_customer_group_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete CustomerGroup by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomerGroup, Integer, Hash)>] CustomerGroup data, response status code and response headers
    def delete_customer_group_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_customer_group_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_customer_group_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_customer_group_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_customer_group_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/customer-groups/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_customer_group_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_customer_group_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete DiscountCode by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [DiscountCode]
    def delete_discount_code_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_discount_code_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete DiscountCode by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(DiscountCode, Integer, Hash)>] DiscountCode data, response status code and response headers
    def delete_discount_code_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_discount_code_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_discount_code_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_discount_code_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_discount_code_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/discount-codes/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DiscountCode'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_discount_code_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_discount_code_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Extension by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Extension]
    def delete_extension_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_extension_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Extension by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Extension, Integer, Hash)>] Extension data, response status code and response headers
    def delete_extension_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_extension_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_extension_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_extension_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_extension_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/extensions/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Extension'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_extension_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_extension_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Extension by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Extension]
    def delete_extension_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_extension_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Extension by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Extension, Integer, Hash)>] Extension data, response status code and response headers
    def delete_extension_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_extension_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_extension_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_extension_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_extension_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/extensions/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Extension'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_extension_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_extension_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete InventoryEntry by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [InventoryEntry]
    def delete_inventory_entry_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_inventory_entry_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete InventoryEntry by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(InventoryEntry, Integer, Hash)>] InventoryEntry data, response status code and response headers
    def delete_inventory_entry_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_inventory_entry_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_inventory_entry_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_inventory_entry_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_inventory_entry_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/inventory/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'InventoryEntry'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_inventory_entry_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_inventory_entry_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete MyCart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyCart]
    def delete_my_cart_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_my_cart_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete MyCart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyCart, Integer, Hash)>] MyCart data, response status code and response headers
    def delete_my_cart_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_my_cart_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_my_cart_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_my_cart_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_my_cart_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyCart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_my_cart_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_my_cart_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Cart by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def delete_my_cart_by_id_in_store(project_key, store_key, id, version, opts = {})
      data, _status_code, _headers = delete_my_cart_by_id_in_store_with_http_info(project_key, store_key, id, version, opts)
      data
    end

    # Delete Cart by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def delete_my_cart_by_id_in_store_with_http_info(project_key, store_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_my_cart_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_my_cart_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.delete_my_cart_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_my_cart_by_id_in_store"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_my_cart_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_my_cart_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_my_cart_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete my Customer
    # @param project_key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @return [MyCustomer]
    def delete_my_customer(project_key, version, opts = {})
      data, _status_code, _headers = delete_my_customer_with_http_info(project_key, version, opts)
      data
    end

    # Delete my Customer
    # @param project_key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @return [Array<(MyCustomer, Integer, Hash)>] MyCustomer data, response status code and response headers
    def delete_my_customer_with_http_info(project_key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_my_customer ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_my_customer"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_my_customer"
      end
      # resource path
      local_var_path = '/{projectKey}/me'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyCustomer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_my_customer",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_my_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete MyPayment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyPayment]
    def delete_my_payment_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_my_payment_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete MyPayment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyPayment, Integer, Hash)>] MyPayment data, response status code and response headers
    def delete_my_payment_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_my_payment_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_my_payment_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_my_payment_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_my_payment_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/payments/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyPayment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_my_payment_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_my_payment_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete MyPayment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyPayment]
    def delete_my_payment_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_my_payment_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete MyPayment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyPayment, Integer, Hash)>] MyPayment data, response status code and response headers
    def delete_my_payment_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_my_payment_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_my_payment_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_my_payment_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_my_payment_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/me/payments/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyPayment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_my_payment_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_my_payment_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete MyShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyShoppingList]
    def delete_my_shopping_list_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_my_shopping_list_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete MyShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyShoppingList, Integer, Hash)>] MyShoppingList data, response status code and response headers
    def delete_my_shopping_list_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_my_shopping_list_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_my_shopping_list_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_my_shopping_list_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_my_shopping_list_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/shopping-lists/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_my_shopping_list_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_my_shopping_list_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete MyShoppingList by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyShoppingList]
    def delete_my_shopping_list_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_my_shopping_list_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete MyShoppingList by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyShoppingList, Integer, Hash)>] MyShoppingList data, response status code and response headers
    def delete_my_shopping_list_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_my_shopping_list_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_my_shopping_list_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_my_shopping_list_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_my_shopping_list_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/me/shopping-lists/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_my_shopping_list_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_my_shopping_list_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Order by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def delete_order_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_order_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Order by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def delete_order_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_order_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_order_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_order_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_order_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_order_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_order_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Order by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def delete_order_by_id_in_store(project_key, store_key, id, version, opts = {})
      data, _status_code, _headers = delete_order_by_id_in_store_with_http_info(project_key, store_key, id, version, opts)
      data
    end

    # Delete Order by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def delete_order_by_id_in_store_with_http_info(project_key, store_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_order_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_order_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.delete_order_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_order_by_id_in_store"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_order_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/orders/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_order_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_order_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Order by orderNumber
    # @param project_key [String] 
    # @param order_number [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def delete_order_by_order_number(project_key, order_number, version, opts = {})
      data, _status_code, _headers = delete_order_by_order_number_with_http_info(project_key, order_number, version, opts)
      data
    end

    # Delete Order by orderNumber
    # @param project_key [String] 
    # @param order_number [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def delete_order_by_order_number_with_http_info(project_key, order_number, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_order_by_order_number ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_order_by_order_number"
      end
      # verify the required parameter 'order_number' is set
      if @api_client.config.client_side_validation && order_number.nil?
        fail ArgumentError, "Missing the required parameter 'order_number' when calling DefaultApi.delete_order_by_order_number"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_order_by_order_number"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/order-number={orderNumber}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'orderNumber' + '}', CGI.escape(order_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_order_by_order_number",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_order_by_order_number\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Order by orderNumber
    # @param project_key [String] 
    # @param store_key [String] 
    # @param order_number [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def delete_order_by_order_number_in_store(project_key, store_key, order_number, version, opts = {})
      data, _status_code, _headers = delete_order_by_order_number_in_store_with_http_info(project_key, store_key, order_number, version, opts)
      data
    end

    # Delete Order by orderNumber
    # @param project_key [String] 
    # @param store_key [String] 
    # @param order_number [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def delete_order_by_order_number_in_store_with_http_info(project_key, store_key, order_number, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_order_by_order_number_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_order_by_order_number_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.delete_order_by_order_number_in_store"
      end
      # verify the required parameter 'order_number' is set
      if @api_client.config.client_side_validation && order_number.nil?
        fail ArgumentError, "Missing the required parameter 'order_number' when calling DefaultApi.delete_order_by_order_number_in_store"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_order_by_order_number_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'orderNumber' + '}', CGI.escape(order_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_order_by_order_number_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_order_by_order_number_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete OrderEdit by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [OrderEdit]
    def delete_order_edit_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_order_edit_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete OrderEdit by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(OrderEdit, Integer, Hash)>] OrderEdit data, response status code and response headers
    def delete_order_edit_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_order_edit_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_order_edit_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_order_edit_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_order_edit_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/edits/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderEdit'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_order_edit_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_order_edit_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete OrderEdit by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [OrderEdit]
    def delete_order_edit_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_order_edit_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete OrderEdit by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(OrderEdit, Integer, Hash)>] OrderEdit data, response status code and response headers
    def delete_order_edit_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_order_edit_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_order_edit_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_order_edit_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_order_edit_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/edits/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderEdit'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_order_edit_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_order_edit_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Payment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Payment]
    def delete_payment_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_payment_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Payment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Payment, Integer, Hash)>] Payment data, response status code and response headers
    def delete_payment_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_payment_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_payment_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_payment_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_payment_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/payments/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Payment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_payment_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_payment_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Payment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Payment]
    def delete_payment_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_payment_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Payment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Payment, Integer, Hash)>] Payment data, response status code and response headers
    def delete_payment_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_payment_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_payment_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_payment_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_payment_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/payments/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Payment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_payment_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_payment_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Product by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Product]
    def delete_product_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_product_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Product by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def delete_product_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_product_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_product_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_product_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_product_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/products/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Product'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_product_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_product_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Product by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Product]
    def delete_product_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_product_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Product by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def delete_product_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_product_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_product_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_product_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_product_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/products/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Product'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_product_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_product_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ProductDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductDiscount]
    def delete_product_discount_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_product_discount_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete ProductDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductDiscount, Integer, Hash)>] ProductDiscount data, response status code and response headers
    def delete_product_discount_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_product_discount_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_product_discount_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_product_discount_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_product_discount_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/product-discounts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_product_discount_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_product_discount_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ProductDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductDiscount]
    def delete_product_discount_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_product_discount_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete ProductDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductDiscount, Integer, Hash)>] ProductDiscount data, response status code and response headers
    def delete_product_discount_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_product_discount_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_product_discount_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_product_discount_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_product_discount_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/product-discounts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_product_discount_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_product_discount_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ProductType by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductType]
    def delete_product_type_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_product_type_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete ProductType by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductType, Integer, Hash)>] ProductType data, response status code and response headers
    def delete_product_type_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_product_type_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_product_type_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_product_type_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_product_type_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/product-types/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductType'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_product_type_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_product_type_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ProductType by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductType]
    def delete_product_type_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_product_type_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete ProductType by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductType, Integer, Hash)>] ProductType data, response status code and response headers
    def delete_product_type_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_product_type_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_product_type_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_product_type_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_product_type_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/product-types/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductType'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_product_type_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_product_type_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Review by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Review]
    def delete_review_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_review_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Review by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Review, Integer, Hash)>] Review data, response status code and response headers
    def delete_review_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_review_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_review_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_review_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_review_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/reviews/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Review'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_review_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_review_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Review by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Review]
    def delete_review_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_review_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Review by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Review, Integer, Hash)>] Review data, response status code and response headers
    def delete_review_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_review_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_review_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_review_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_review_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/reviews/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Review'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_review_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_review_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ShippingMethod by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethod]
    def delete_shipping_method_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_shipping_method_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete ShippingMethod by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethod, Integer, Hash)>] ShippingMethod data, response status code and response headers
    def delete_shipping_method_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_shipping_method_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_shipping_method_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_shipping_method_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_shipping_method_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethod'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_shipping_method_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_shipping_method_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ShippingMethod by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethod]
    def delete_shipping_method_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_shipping_method_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete ShippingMethod by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethod, Integer, Hash)>] ShippingMethod data, response status code and response headers
    def delete_shipping_method_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_shipping_method_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_shipping_method_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_shipping_method_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_shipping_method_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethod'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_shipping_method_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_shipping_method_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [ShoppingList]
    def delete_shopping_list_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_shopping_list_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete ShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShoppingList, Integer, Hash)>] ShoppingList data, response status code and response headers
    def delete_shopping_list_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_shopping_list_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_shopping_list_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_shopping_list_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_shopping_list_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/shopping-lists/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_shopping_list_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_shopping_list_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete ShoppingList by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [ShoppingList]
    def delete_shopping_list_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_shopping_list_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete ShoppingList by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :data_erasure 
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShoppingList, Integer, Hash)>] ShoppingList data, response status code and response headers
    def delete_shopping_list_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_shopping_list_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_shopping_list_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_shopping_list_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_shopping_list_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/shopping-lists/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'dataErasure'] = opts[:'data_erasure'] if !opts[:'data_erasure'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_shopping_list_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_shopping_list_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete State by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [State]
    def delete_state_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_state_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete State by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(State, Integer, Hash)>] State data, response status code and response headers
    def delete_state_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_state_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_state_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_state_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_state_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/states/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'State'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_state_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_state_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete State by Key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [State]
    def delete_state_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_state_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete State by Key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(State, Integer, Hash)>] State data, response status code and response headers
    def delete_state_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_state_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_state_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_state_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_state_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/states/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'State'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_state_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_state_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Store by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Store]
    def delete_store_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_store_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Store by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Store, Integer, Hash)>] Store data, response status code and response headers
    def delete_store_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_store_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_store_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_store_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_store_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/stores/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Store'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_store_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_store_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Store by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Store]
    def delete_store_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_store_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Store by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Store, Integer, Hash)>] Store data, response status code and response headers
    def delete_store_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_store_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_store_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_store_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_store_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/stores/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Store'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_store_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_store_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Subscription by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Subscription]
    def delete_subscription_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_subscription_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Subscription by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def delete_subscription_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_subscription_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_subscription_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_subscription_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_subscription_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/subscriptions/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Subscription'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_subscription_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_subscription_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Subscription by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Subscription]
    def delete_subscription_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_subscription_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Subscription by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def delete_subscription_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_subscription_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_subscription_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_subscription_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_subscription_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/subscriptions/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Subscription'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_subscription_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_subscription_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete TaxCategory by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [TaxCategory]
    def delete_tax_category_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_tax_category_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete TaxCategory by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(TaxCategory, Integer, Hash)>] TaxCategory data, response status code and response headers
    def delete_tax_category_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_tax_category_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_tax_category_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_tax_category_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_tax_category_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/tax-categories/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TaxCategory'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_tax_category_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_tax_category_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete TaxCategory by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [TaxCategory]
    def delete_tax_category_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_tax_category_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete TaxCategory by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(TaxCategory, Integer, Hash)>] TaxCategory data, response status code and response headers
    def delete_tax_category_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_tax_category_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_tax_category_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_tax_category_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_tax_category_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/tax-categories/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TaxCategory'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_tax_category_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_tax_category_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Type by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Type]
    def delete_type_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_type_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Type by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Type, Integer, Hash)>] Type data, response status code and response headers
    def delete_type_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_type_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_type_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_type_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_type_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/types/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Type'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_type_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_type_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Type by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Type]
    def delete_type_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_type_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Type by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Type, Integer, Hash)>] Type data, response status code and response headers
    def delete_type_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_type_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_type_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_type_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_type_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/types/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Type'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_type_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_type_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Zone by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Zone]
    def delete_zone_by_id(project_key, id, version, opts = {})
      data, _status_code, _headers = delete_zone_by_id_with_http_info(project_key, id, version, opts)
      data
    end

    # Delete Zone by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Zone, Integer, Hash)>] Zone data, response status code and response headers
    def delete_zone_by_id_with_http_info(project_key, id, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_zone_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_zone_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.delete_zone_by_id"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_zone_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/zones/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Zone'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_zone_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_zone_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Zone by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Zone]
    def delete_zone_by_key(project_key, key, version, opts = {})
      data, _status_code, _headers = delete_zone_by_key_with_http_info(project_key, key, version, opts)
      data
    end

    # Delete Zone by key
    # @param project_key [String] 
    # @param key [String] 
    # @param version [Integer] Last seen version of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Zone, Integer, Hash)>] Zone data, response status code and response headers
    def delete_zone_by_key_with_http_info(project_key, key, version, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_zone_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.delete_zone_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.delete_zone_by_key"
      end
      # verify the required parameter 'version' is set
      if @api_client.config.client_side_validation && version.nil?
        fail ArgumentError, "Missing the required parameter 'version' when calling DefaultApi.delete_zone_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/zones/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'version'] = version
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Zone'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_zone_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_zone_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get ApiClient by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiClient]
    def get_api_client_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_api_client_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get ApiClient by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiClient, Integer, Hash)>] ApiClient data, response status code and response headers
    def get_api_client_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_client_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_api_client_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_api_client_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/api-clients/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiClient'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_client_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_client_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieves the active cart of the customer that has been modified most recently. It does not consider carts with CartOrigin Merchant. If no active cart exists, a 404 Not Found error is returned.  The cart may not contain up-to-date prices, discounts etc. If you want to ensure they're up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param customer_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def get_cart_by_customer_id(project_key, customer_id, opts = {})
      data, _status_code, _headers = get_cart_by_customer_id_with_http_info(project_key, customer_id, opts)
      data
    end

    # Retrieves the active cart of the customer that has been modified most recently. It does not consider carts with CartOrigin Merchant. If no active cart exists, a 404 Not Found error is returned.  The cart may not contain up-to-date prices, discounts etc. If you want to ensure they&#39;re up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param customer_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def get_cart_by_customer_id_with_http_info(project_key, customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cart_by_customer_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_cart_by_customer_id"
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling DefaultApi.get_cart_by_customer_id"
      end
      # resource path
      local_var_path = '/{projectKey}/carts/customer-id={customerId}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_cart_by_customer_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cart_by_customer_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieves the active cart of the customer that has been modified most recently in a specific Store. The {storeKey} path parameter maps to a Store's key.  If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.  The cart may not contain up-to-date prices, discounts etc. If you want to ensure they're up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def get_cart_by_customer_id_in_store(project_key, store_key, customer_id, opts = {})
      data, _status_code, _headers = get_cart_by_customer_id_in_store_with_http_info(project_key, store_key, customer_id, opts)
      data
    end

    # Retrieves the active cart of the customer that has been modified most recently in a specific Store. The {storeKey} path parameter maps to a Store&#39;s key.  If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.  The cart may not contain up-to-date prices, discounts etc. If you want to ensure they&#39;re up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def get_cart_by_customer_id_in_store_with_http_info(project_key, store_key, customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cart_by_customer_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_cart_by_customer_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_cart_by_customer_id_in_store"
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling DefaultApi.get_cart_by_customer_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts/customer-id={customerId}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_cart_by_customer_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cart_by_customer_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # The cart may not contain up-to-date prices, discounts etc. If you want to ensure they're up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def get_cart_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_cart_by_id_with_http_info(project_key, id, opts)
      data
    end

    # The cart may not contain up-to-date prices, discounts etc. If you want to ensure they&#39;re up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def get_cart_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cart_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_cart_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_cart_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_cart_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cart_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns a cart by its ID from a specific Store. The {storeKey} path parameter maps to a Store's key. If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error. The cart may not contain up-to-date prices, discounts etc. If you want to ensure they're up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def get_cart_by_id_in_store(project_key, store_key, id, opts = {})
      data, _status_code, _headers = get_cart_by_id_in_store_with_http_info(project_key, store_key, id, opts)
      data
    end

    # Returns a cart by its ID from a specific Store. The {storeKey} path parameter maps to a Store&#39;s key. If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error. The cart may not contain up-to-date prices, discounts etc. If you want to ensure they&#39;re up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def get_cart_by_id_in_store_with_http_info(project_key, store_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cart_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_cart_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_cart_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_cart_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_cart_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cart_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # The cart may not contain up-to-date prices, discounts etc. If you want to ensure they're up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def get_cart_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_cart_by_key_with_http_info(project_key, key, opts)
      data
    end

    # The cart may not contain up-to-date prices, discounts etc. If you want to ensure they&#39;re up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def get_cart_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cart_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_cart_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_cart_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/carts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_cart_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cart_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns a cart by its key from a specific Store. The {storeKey} path parameter maps to a Store's key. If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error. The cart may not contain up-to-date prices, discounts etc. If you want to ensure they're up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def get_cart_by_key_in_store(project_key, store_key, key, opts = {})
      data, _status_code, _headers = get_cart_by_key_in_store_with_http_info(project_key, store_key, key, opts)
      data
    end

    # Returns a cart by its key from a specific Store. The {storeKey} path parameter maps to a Store&#39;s key. If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error. The cart may not contain up-to-date prices, discounts etc. If you want to ensure they&#39;re up-to-date, send an Update request with the Recalculate update action instead.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def get_cart_by_key_in_store_with_http_info(project_key, store_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cart_by_key_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_cart_by_key_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_cart_by_key_in_store"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_cart_by_key_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_cart_by_key_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cart_by_key_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get CartDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CartDiscount]
    def get_cart_discount_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_cart_discount_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get CartDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CartDiscount, Integer, Hash)>] CartDiscount data, response status code and response headers
    def get_cart_discount_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cart_discount_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_cart_discount_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_cart_discount_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/cart-discounts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CartDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_cart_discount_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cart_discount_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get CartDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CartDiscount]
    def get_cart_discount_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_cart_discount_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get CartDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CartDiscount, Integer, Hash)>] CartDiscount data, response status code and response headers
    def get_cart_discount_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_cart_discount_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_cart_discount_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_cart_discount_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/cart-discounts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CartDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_cart_discount_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_cart_discount_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Category by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Category]
    def get_category_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_category_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Category by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Category, Integer, Hash)>] Category data, response status code and response headers
    def get_category_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_category_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_category_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_category_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/categories/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Category'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_category_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_category_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Category by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Category]
    def get_category_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_category_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get Category by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Category, Integer, Hash)>] Category data, response status code and response headers
    def get_category_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_category_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_category_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_category_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/categories/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Category'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_category_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_category_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Channel by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Channel]
    def get_channel_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_channel_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Channel by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Channel, Integer, Hash)>] Channel data, response status code and response headers
    def get_channel_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_channel_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_channel_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_channel_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/channels/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Channel'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_channel_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_channel_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get CustomObject by container
    # @param project_key [String] 
    # @param container [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CustomObject]
    def get_custom_object_by_container(project_key, container, opts = {})
      data, _status_code, _headers = get_custom_object_by_container_with_http_info(project_key, container, opts)
      data
    end

    # Get CustomObject by container
    # @param project_key [String] 
    # @param container [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomObject, Integer, Hash)>] CustomObject data, response status code and response headers
    def get_custom_object_by_container_with_http_info(project_key, container, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_custom_object_by_container ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_custom_object_by_container"
      end
      # verify the required parameter 'container' is set
      if @api_client.config.client_side_validation && container.nil?
        fail ArgumentError, "Missing the required parameter 'container' when calling DefaultApi.get_custom_object_by_container"
      end
      # resource path
      local_var_path = '/{projectKey}/custom-objects/{container}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'container' + '}', CGI.escape(container.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomObject'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_custom_object_by_container",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_custom_object_by_container\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get CustomObject by container and key
    # @param project_key [String] 
    # @param container [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CustomObject]
    def get_custom_object_by_container_and_key(project_key, container, key, opts = {})
      data, _status_code, _headers = get_custom_object_by_container_and_key_with_http_info(project_key, container, key, opts)
      data
    end

    # Get CustomObject by container and key
    # @param project_key [String] 
    # @param container [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomObject, Integer, Hash)>] CustomObject data, response status code and response headers
    def get_custom_object_by_container_and_key_with_http_info(project_key, container, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_custom_object_by_container_and_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_custom_object_by_container_and_key"
      end
      # verify the required parameter 'container' is set
      if @api_client.config.client_side_validation && container.nil?
        fail ArgumentError, "Missing the required parameter 'container' when calling DefaultApi.get_custom_object_by_container_and_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_custom_object_by_container_and_key"
      end
      # resource path
      local_var_path = '/{projectKey}/custom-objects/{container}/{key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'container' + '}', CGI.escape(container.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomObject'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_custom_object_by_container_and_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_custom_object_by_container_and_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Customer by emailToken
    # @param project_key [String] 
    # @param email_token [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def get_customer_by_email_verification_token(project_key, email_token, opts = {})
      data, _status_code, _headers = get_customer_by_email_verification_token_with_http_info(project_key, email_token, opts)
      data
    end

    # Get Customer by emailToken
    # @param project_key [String] 
    # @param email_token [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def get_customer_by_email_verification_token_with_http_info(project_key, email_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_by_email_verification_token ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_by_email_verification_token"
      end
      # verify the required parameter 'email_token' is set
      if @api_client.config.client_side_validation && email_token.nil?
        fail ArgumentError, "Missing the required parameter 'email_token' when calling DefaultApi.get_customer_by_email_verification_token"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/email-token={emailToken}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'emailToken' + '}', CGI.escape(email_token.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_by_email_verification_token",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_by_email_verification_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Customer by emailToken
    # @param project_key [String] 
    # @param store_key [String] 
    # @param email_token [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def get_customer_by_email_verification_token_in_store(project_key, store_key, email_token, opts = {})
      data, _status_code, _headers = get_customer_by_email_verification_token_in_store_with_http_info(project_key, store_key, email_token, opts)
      data
    end

    # Get Customer by emailToken
    # @param project_key [String] 
    # @param store_key [String] 
    # @param email_token [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def get_customer_by_email_verification_token_in_store_with_http_info(project_key, store_key, email_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_by_email_verification_token_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_by_email_verification_token_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_customer_by_email_verification_token_in_store"
      end
      # verify the required parameter 'email_token' is set
      if @api_client.config.client_side_validation && email_token.nil?
        fail ArgumentError, "Missing the required parameter 'email_token' when calling DefaultApi.get_customer_by_email_verification_token_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/email-token={emailToken}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'emailToken' + '}', CGI.escape(email_token.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_by_email_verification_token_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_by_email_verification_token_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Customer by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def get_customer_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_customer_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Customer by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def get_customer_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_customer_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns a customer by its ID from a specific Store. The {storeKey} path parameter maps to a Store's key. It also considers customers that do not have the stores field. If the customer exists in the commercetools project but the stores field references different stores, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def get_customer_by_id_in_store(project_key, store_key, id, opts = {})
      data, _status_code, _headers = get_customer_by_id_in_store_with_http_info(project_key, store_key, id, opts)
      data
    end

    # Returns a customer by its ID from a specific Store. The {storeKey} path parameter maps to a Store&#39;s key. It also considers customers that do not have the stores field. If the customer exists in the commercetools project but the stores field references different stores, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def get_customer_by_id_in_store_with_http_info(project_key, store_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_customer_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_customer_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Customer by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def get_customer_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_customer_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get Customer by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def get_customer_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_customer_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns a customer by its Key from a specific Store. The {storeKey} path parameter maps to a Store's key. It also considers customers that do not have the stores field. If the customer exists in the commercetools project but the stores field references different stores, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def get_customer_by_key_in_store(project_key, store_key, key, opts = {})
      data, _status_code, _headers = get_customer_by_key_in_store_with_http_info(project_key, store_key, key, opts)
      data
    end

    # Returns a customer by its Key from a specific Store. The {storeKey} path parameter maps to a Store&#39;s key. It also considers customers that do not have the stores field. If the customer exists in the commercetools project but the stores field references different stores, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def get_customer_by_key_in_store_with_http_info(project_key, store_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_by_key_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_by_key_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_customer_by_key_in_store"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_customer_by_key_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_by_key_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_by_key_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Customer by passwordToken
    # @param project_key [String] 
    # @param password_token [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def get_customer_by_password_verification_token(project_key, password_token, opts = {})
      data, _status_code, _headers = get_customer_by_password_verification_token_with_http_info(project_key, password_token, opts)
      data
    end

    # Get Customer by passwordToken
    # @param project_key [String] 
    # @param password_token [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def get_customer_by_password_verification_token_with_http_info(project_key, password_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_by_password_verification_token ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_by_password_verification_token"
      end
      # verify the required parameter 'password_token' is set
      if @api_client.config.client_side_validation && password_token.nil?
        fail ArgumentError, "Missing the required parameter 'password_token' when calling DefaultApi.get_customer_by_password_verification_token"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/password-token={passwordToken}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'passwordToken' + '}', CGI.escape(password_token.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_by_password_verification_token",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_by_password_verification_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Customer by passwordToken
    # @param project_key [String] 
    # @param store_key [String] 
    # @param password_token [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def get_customer_by_password_verification_token_in_store(project_key, store_key, password_token, opts = {})
      data, _status_code, _headers = get_customer_by_password_verification_token_in_store_with_http_info(project_key, store_key, password_token, opts)
      data
    end

    # Get Customer by passwordToken
    # @param project_key [String] 
    # @param store_key [String] 
    # @param password_token [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def get_customer_by_password_verification_token_in_store_with_http_info(project_key, store_key, password_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_by_password_verification_token_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_by_password_verification_token_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_customer_by_password_verification_token_in_store"
      end
      # verify the required parameter 'password_token' is set
      if @api_client.config.client_side_validation && password_token.nil?
        fail ArgumentError, "Missing the required parameter 'password_token' when calling DefaultApi.get_customer_by_password_verification_token_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/password-token={passwordToken}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'passwordToken' + '}', CGI.escape(password_token.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_by_password_verification_token_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_by_password_verification_token_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get CustomerGroup by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CustomerGroup]
    def get_customer_group_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_customer_group_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get CustomerGroup by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomerGroup, Integer, Hash)>] CustomerGroup data, response status code and response headers
    def get_customer_group_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_group_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_group_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_customer_group_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/customer-groups/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_group_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_group_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Gets a customer group by Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CustomerGroup]
    def get_customer_group_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_customer_group_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Gets a customer group by Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomerGroup, Integer, Hash)>] CustomerGroup data, response status code and response headers
    def get_customer_group_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_customer_group_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_customer_group_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_customer_group_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/customer-groups/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_customer_group_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_customer_group_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get DiscountCode by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [DiscountCode]
    def get_discount_code_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_discount_code_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get DiscountCode by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(DiscountCode, Integer, Hash)>] DiscountCode data, response status code and response headers
    def get_discount_code_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_discount_code_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_discount_code_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_discount_code_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/discount-codes/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DiscountCode'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_discount_code_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_discount_code_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieves the representation of an extension by its id.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Extension]
    def get_extension_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_extension_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Retrieves the representation of an extension by its id.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Extension, Integer, Hash)>] Extension data, response status code and response headers
    def get_extension_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_extension_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_extension_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_extension_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/extensions/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Extension'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_extension_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_extension_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieves the representation of an extension by its key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Extension]
    def get_extension_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_extension_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Retrieves the representation of an extension by its key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Extension, Integer, Hash)>] Extension data, response status code and response headers
    def get_extension_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_extension_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_extension_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_extension_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/extensions/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Extension'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_extension_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_extension_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get InventoryEntry by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [InventoryEntry]
    def get_inventory_entry_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_inventory_entry_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get InventoryEntry by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(InventoryEntry, Integer, Hash)>] InventoryEntry data, response status code and response headers
    def get_inventory_entry_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_inventory_entry_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_inventory_entry_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_inventory_entry_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/inventory/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'InventoryEntry'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_inventory_entry_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_inventory_entry_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param product_discount_match_query [ProductDiscountMatchQuery] 
    # @param [Hash] opts the optional parameters
    # @return [ProductDiscount]
    def get_matching_product_discounts(project_key, product_discount_match_query, opts = {})
      data, _status_code, _headers = get_matching_product_discounts_with_http_info(project_key, product_discount_match_query, opts)
      data
    end

    # @param project_key [String] 
    # @param product_discount_match_query [ProductDiscountMatchQuery] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ProductDiscount, Integer, Hash)>] ProductDiscount data, response status code and response headers
    def get_matching_product_discounts_with_http_info(project_key, product_discount_match_query, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_matching_product_discounts ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_matching_product_discounts"
      end
      # verify the required parameter 'product_discount_match_query' is set
      if @api_client.config.client_side_validation && product_discount_match_query.nil?
        fail ArgumentError, "Missing the required parameter 'product_discount_match_query' when calling DefaultApi.get_matching_product_discounts"
      end
      # resource path
      local_var_path = '/{projectKey}/product-discounts/matching'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_discount_match_query)

      # return_type
      return_type = opts[:debug_return_type] || 'ProductDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_matching_product_discounts",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_matching_product_discounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Message by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Message]
    def get_message_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_message_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Message by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Message, Integer, Hash)>] Message data, response status code and response headers
    def get_message_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_message_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_message_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_message_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/messages/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Message'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_message_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_message_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [MyCart]
    def get_my_active_cart(project_key, opts = {})
      data, _status_code, _headers = get_my_active_cart_with_http_info(project_key, opts)
      data
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MyCart, Integer, Hash)>] MyCart data, response status code and response headers
    def get_my_active_cart_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_active_cart ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_active_cart"
      end
      # resource path
      local_var_path = '/{projectKey}/me/active-cart'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyCart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_active_cart",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_active_cart\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Cart]
    def get_my_active_cart_in_store(project_key, store_key, opts = {})
      data, _status_code, _headers = get_my_active_cart_in_store_with_http_info(project_key, store_key, opts)
      data
    end

    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def get_my_active_cart_in_store_with_http_info(project_key, store_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_active_cart_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_active_cart_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_my_active_cart_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/active-cart'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_active_cart_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_active_cart_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get MyCart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyCart]
    def get_my_cart_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_my_cart_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get MyCart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyCart, Integer, Hash)>] MyCart data, response status code and response headers
    def get_my_cart_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_cart_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_cart_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_my_cart_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyCart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_cart_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_cart_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Cart by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def get_my_cart_by_id_in_store(project_key, store_key, id, opts = {})
      data, _status_code, _headers = get_my_cart_by_id_in_store_with_http_info(project_key, store_key, id, opts)
      data
    end

    # Get Cart by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def get_my_cart_by_id_in_store_with_http_info(project_key, store_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_cart_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_cart_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_my_cart_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_my_cart_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_cart_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_cart_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [MyCustomer]
    def get_my_customer_details(project_key, opts = {})
      data, _status_code, _headers = get_my_customer_details_with_http_info(project_key, opts)
      data
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(MyCustomer, Integer, Hash)>] MyCustomer data, response status code and response headers
    def get_my_customer_details_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_customer_details ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_customer_details"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.get_my_customer_details, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/me'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyCustomer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_customer_details",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_customer_details\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get MyOrder by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyOrder]
    def get_my_order_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_my_order_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get MyOrder by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyOrder, Integer, Hash)>] MyOrder data, response status code and response headers
    def get_my_order_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_order_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_order_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_my_order_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/orders/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyOrder'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_order_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_order_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Order by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def get_my_order_by_id_in_store(project_key, store_key, id, opts = {})
      data, _status_code, _headers = get_my_order_by_id_in_store_with_http_info(project_key, store_key, id, opts)
      data
    end

    # Get Order by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def get_my_order_by_id_in_store_with_http_info(project_key, store_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_order_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_order_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_my_order_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_my_order_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/orders/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_order_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_order_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get MyPayment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyPayment]
    def get_my_payment_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_my_payment_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get MyPayment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyPayment, Integer, Hash)>] MyPayment data, response status code and response headers
    def get_my_payment_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_payment_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_payment_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_my_payment_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/payments/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyPayment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_payment_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_payment_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get MyPayment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyPayment]
    def get_my_payment_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_my_payment_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get MyPayment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyPayment, Integer, Hash)>] MyPayment data, response status code and response headers
    def get_my_payment_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_payment_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_payment_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_my_payment_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/me/payments/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyPayment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_payment_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_payment_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get MyShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyShoppingList]
    def get_my_shopping_list_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_my_shopping_list_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get MyShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyShoppingList, Integer, Hash)>] MyShoppingList data, response status code and response headers
    def get_my_shopping_list_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_shopping_list_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_shopping_list_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_my_shopping_list_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/shopping-lists/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_shopping_list_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_shopping_list_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get MyShoppingList by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyShoppingList]
    def get_my_shopping_list_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_my_shopping_list_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get MyShoppingList by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyShoppingList, Integer, Hash)>] MyShoppingList data, response status code and response headers
    def get_my_shopping_list_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_my_shopping_list_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_my_shopping_list_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_my_shopping_list_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/me/shopping-lists/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_my_shopping_list_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_my_shopping_list_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Order by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def get_order_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_order_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Order by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def get_order_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_order_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_order_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_order_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_order_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_order_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns an order by its ID from a specific Store. The {storeKey} path parameter maps to a Store's key. If the order exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def get_order_by_id_in_store(project_key, store_key, id, opts = {})
      data, _status_code, _headers = get_order_by_id_in_store_with_http_info(project_key, store_key, id, opts)
      data
    end

    # Returns an order by its ID from a specific Store. The {storeKey} path parameter maps to a Store&#39;s key. If the order exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def get_order_by_id_in_store_with_http_info(project_key, store_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_order_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_order_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_order_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_order_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/orders/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_order_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_order_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # In case the orderNumber does not match the regular expression [a-zA-Z0-9_-]+, it should be provided in URL-encoded format.
    # @param project_key [String] 
    # @param order_number [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def get_order_by_order_number(project_key, order_number, opts = {})
      data, _status_code, _headers = get_order_by_order_number_with_http_info(project_key, order_number, opts)
      data
    end

    # In case the orderNumber does not match the regular expression [a-zA-Z0-9_-]+, it should be provided in URL-encoded format.
    # @param project_key [String] 
    # @param order_number [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def get_order_by_order_number_with_http_info(project_key, order_number, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_order_by_order_number ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_order_by_order_number"
      end
      # verify the required parameter 'order_number' is set
      if @api_client.config.client_side_validation && order_number.nil?
        fail ArgumentError, "Missing the required parameter 'order_number' when calling DefaultApi.get_order_by_order_number"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/order-number={orderNumber}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'orderNumber' + '}', CGI.escape(order_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_order_by_order_number",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_order_by_order_number\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Returns an order by its order number from a specific Store. The {storeKey} path parameter maps to a Store's key. If the order exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error. In case the orderNumber does not match the regular expression [a-zA-Z0-9_-]+, it should be provided in URL-encoded format.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param order_number [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def get_order_by_order_number_in_store(project_key, store_key, order_number, opts = {})
      data, _status_code, _headers = get_order_by_order_number_in_store_with_http_info(project_key, store_key, order_number, opts)
      data
    end

    # Returns an order by its order number from a specific Store. The {storeKey} path parameter maps to a Store&#39;s key. If the order exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error. In case the orderNumber does not match the regular expression [a-zA-Z0-9_-]+, it should be provided in URL-encoded format.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param order_number [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def get_order_by_order_number_in_store_with_http_info(project_key, store_key, order_number, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_order_by_order_number_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_order_by_order_number_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_order_by_order_number_in_store"
      end
      # verify the required parameter 'order_number' is set
      if @api_client.config.client_side_validation && order_number.nil?
        fail ArgumentError, "Missing the required parameter 'order_number' when calling DefaultApi.get_order_by_order_number_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'orderNumber' + '}', CGI.escape(order_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_order_by_order_number_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_order_by_order_number_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get OrderEdit by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [OrderEdit]
    def get_order_edit_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_order_edit_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get OrderEdit by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(OrderEdit, Integer, Hash)>] OrderEdit data, response status code and response headers
    def get_order_edit_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_order_edit_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_order_edit_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_order_edit_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/edits/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderEdit'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_order_edit_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_order_edit_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get OrderEdit by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [OrderEdit]
    def get_order_edit_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_order_edit_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get OrderEdit by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(OrderEdit, Integer, Hash)>] OrderEdit data, response status code and response headers
    def get_order_edit_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_order_edit_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_order_edit_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_order_edit_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/edits/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderEdit'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_order_edit_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_order_edit_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Payment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Payment]
    def get_payment_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_payment_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Payment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Payment, Integer, Hash)>] Payment data, response status code and response headers
    def get_payment_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_payment_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_payment_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_payment_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/payments/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Payment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_payment_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_payment_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Payment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Payment]
    def get_payment_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_payment_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get Payment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Payment, Integer, Hash)>] Payment data, response status code and response headers
    def get_payment_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_payment_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_payment_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_payment_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/payments/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Payment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_payment_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_payment_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Gets the full representation of a product by ID.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Product]
    def get_product_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_product_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Gets the full representation of a product by ID.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def get_product_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_product_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_product_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_product_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/products/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Product'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_product_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_product_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Gets the full representation of a product by Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Product]
    def get_product_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_product_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Gets the full representation of a product by Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def get_product_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_product_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_product_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_product_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/products/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Product'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_product_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_product_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get ProductDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductDiscount]
    def get_product_discount_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_product_discount_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get ProductDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductDiscount, Integer, Hash)>] ProductDiscount data, response status code and response headers
    def get_product_discount_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_product_discount_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_product_discount_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_product_discount_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/product-discounts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_product_discount_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_product_discount_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get ProductDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductDiscount]
    def get_product_discount_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_product_discount_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get ProductDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductDiscount, Integer, Hash)>] ProductDiscount data, response status code and response headers
    def get_product_discount_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_product_discount_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_product_discount_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_product_discount_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/product-discounts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_product_discount_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_product_discount_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Gets the current or staged representation of a product in a catalog by ID. When used with an API client that has the view_published_products:{projectKey} scope, this endpoint only returns published (current) product projections.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [ProductProjection]
    def get_product_projection_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_product_projection_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Gets the current or staged representation of a product in a catalog by ID. When used with an API client that has the view_published_products:{projectKey} scope, this endpoint only returns published (current) product projections.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductProjection, Integer, Hash)>] ProductProjection data, response status code and response headers
    def get_product_projection_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_product_projection_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_product_projection_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_product_projection_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/product-projections/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'staged'] = opts[:'staged'] if !opts[:'staged'].nil?
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductProjection'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_product_projection_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_product_projection_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Gets the current or staged representation of a product found by Key. When used with an API client that has the view_published_products:{projectKey} scope, this endpoint only returns published (current) product projections.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [ProductProjection]
    def get_product_projection_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_product_projection_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Gets the current or staged representation of a product found by Key. When used with an API client that has the view_published_products:{projectKey} scope, this endpoint only returns published (current) product projections.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductProjection, Integer, Hash)>] ProductProjection data, response status code and response headers
    def get_product_projection_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_product_projection_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_product_projection_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_product_projection_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/product-projections/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'staged'] = opts[:'staged'] if !opts[:'staged'].nil?
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductProjection'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_product_projection_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_product_projection_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get ProductType by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductType]
    def get_product_type_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_product_type_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get ProductType by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductType, Integer, Hash)>] ProductType data, response status code and response headers
    def get_product_type_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_product_type_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_product_type_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_product_type_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/product-types/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductType'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_product_type_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_product_type_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get ProductType by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductType]
    def get_product_type_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_product_type_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get ProductType by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductType, Integer, Hash)>] ProductType data, response status code and response headers
    def get_product_type_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_product_type_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_product_type_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_product_type_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/product-types/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductType'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_product_type_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_product_type_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # The Endpoint is responding a limited set of information about settings and configuration of the project.
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Project]
    def get_project_settings(project_key, opts = {})
      data, _status_code, _headers = get_project_settings_with_http_info(project_key, opts)
      data
    end

    # The Endpoint is responding a limited set of information about settings and configuration of the project.
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Project, Integer, Hash)>] Project data, response status code and response headers
    def get_project_settings_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_project_settings ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_project_settings"
      end
      # resource path
      local_var_path = '/{projectKey}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Project'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_project_settings",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_project_settings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Review by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Review]
    def get_review_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_review_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Review by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Review, Integer, Hash)>] Review data, response status code and response headers
    def get_review_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_review_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_review_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_review_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/reviews/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Review'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_review_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_review_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Review by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Review]
    def get_review_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_review_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get Review by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Review, Integer, Hash)>] Review data, response status code and response headers
    def get_review_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_review_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_review_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_review_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/reviews/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Review'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_review_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_review_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get ShippingMethod by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethod]
    def get_shipping_method_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_shipping_method_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get ShippingMethod by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethod, Integer, Hash)>] ShippingMethod data, response status code and response headers
    def get_shipping_method_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_shipping_method_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_shipping_method_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_shipping_method_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethod'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_shipping_method_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_shipping_method_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get ShippingMethod by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethod]
    def get_shipping_method_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_shipping_method_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get ShippingMethod by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethod, Integer, Hash)>] ShippingMethod data, response status code and response headers
    def get_shipping_method_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_shipping_method_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_shipping_method_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_shipping_method_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethod'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_shipping_method_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_shipping_method_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param cart_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethodPagedQueryResponse]
    def get_shipping_methods_for_a_cart(project_key, cart_id, opts = {})
      data, _status_code, _headers = get_shipping_methods_for_a_cart_with_http_info(project_key, cart_id, opts)
      data
    end

    # @param project_key [String] 
    # @param cart_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethodPagedQueryResponse, Integer, Hash)>] ShippingMethodPagedQueryResponse data, response status code and response headers
    def get_shipping_methods_for_a_cart_with_http_info(project_key, cart_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_shipping_methods_for_a_cart ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_shipping_methods_for_a_cart"
      end
      # verify the required parameter 'cart_id' is set
      if @api_client.config.client_side_validation && cart_id.nil?
        fail ArgumentError, "Missing the required parameter 'cart_id' when calling DefaultApi.get_shipping_methods_for_a_cart"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/matching-cart'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cartId'] = cart_id
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethodPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_shipping_methods_for_a_cart",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_shipping_methods_for_a_cart\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param store_key [String] 
    # @param cart_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethodPagedQueryResponse]
    def get_shipping_methods_for_a_cart_in_a_store(project_key, store_key, cart_id, opts = {})
      data, _status_code, _headers = get_shipping_methods_for_a_cart_in_a_store_with_http_info(project_key, store_key, cart_id, opts)
      data
    end

    # @param project_key [String] 
    # @param store_key [String] 
    # @param cart_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethodPagedQueryResponse, Integer, Hash)>] ShippingMethodPagedQueryResponse data, response status code and response headers
    def get_shipping_methods_for_a_cart_in_a_store_with_http_info(project_key, store_key, cart_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_shipping_methods_for_a_cart_in_a_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_shipping_methods_for_a_cart_in_a_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.get_shipping_methods_for_a_cart_in_a_store"
      end
      # verify the required parameter 'cart_id' is set
      if @api_client.config.client_side_validation && cart_id.nil?
        fail ArgumentError, "Missing the required parameter 'cart_id' when calling DefaultApi.get_shipping_methods_for_a_cart_in_a_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/shipping-methods/matching-cart'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cartId'] = cart_id
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethodPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_shipping_methods_for_a_cart_in_a_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_shipping_methods_for_a_cart_in_a_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param country [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :state 
    # @option opts [String] :currency 
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethodPagedQueryResponse]
    def get_shipping_methods_for_a_location(project_key, country, opts = {})
      data, _status_code, _headers = get_shipping_methods_for_a_location_with_http_info(project_key, country, opts)
      data
    end

    # @param project_key [String] 
    # @param country [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :state 
    # @option opts [String] :currency 
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethodPagedQueryResponse, Integer, Hash)>] ShippingMethodPagedQueryResponse data, response status code and response headers
    def get_shipping_methods_for_a_location_with_http_info(project_key, country, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_shipping_methods_for_a_location ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_shipping_methods_for_a_location"
      end
      # verify the required parameter 'country' is set
      if @api_client.config.client_side_validation && country.nil?
        fail ArgumentError, "Missing the required parameter 'country' when calling DefaultApi.get_shipping_methods_for_a_location"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/matching-location'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'country'] = country
      query_params[:'state'] = opts[:'state'] if !opts[:'state'].nil?
      query_params[:'currency'] = opts[:'currency'] if !opts[:'currency'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethodPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_shipping_methods_for_a_location",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_shipping_methods_for_a_location\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param order_edit_id [String] 
    # @param country [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :state 
    # @return [ShippingMethodPagedQueryResponse]
    def get_shipping_methods_for_an_order_edit(project_key, order_edit_id, country, opts = {})
      data, _status_code, _headers = get_shipping_methods_for_an_order_edit_with_http_info(project_key, order_edit_id, country, opts)
      data
    end

    # @param project_key [String] 
    # @param order_edit_id [String] 
    # @param country [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :state 
    # @return [Array<(ShippingMethodPagedQueryResponse, Integer, Hash)>] ShippingMethodPagedQueryResponse data, response status code and response headers
    def get_shipping_methods_for_an_order_edit_with_http_info(project_key, order_edit_id, country, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_shipping_methods_for_an_order_edit ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_shipping_methods_for_an_order_edit"
      end
      # verify the required parameter 'order_edit_id' is set
      if @api_client.config.client_side_validation && order_edit_id.nil?
        fail ArgumentError, "Missing the required parameter 'order_edit_id' when calling DefaultApi.get_shipping_methods_for_an_order_edit"
      end
      # verify the required parameter 'country' is set
      if @api_client.config.client_side_validation && country.nil?
        fail ArgumentError, "Missing the required parameter 'country' when calling DefaultApi.get_shipping_methods_for_an_order_edit"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/matching-orderedit'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'orderEditId'] = order_edit_id
      query_params[:'country'] = country
      query_params[:'state'] = opts[:'state'] if !opts[:'state'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethodPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_shipping_methods_for_an_order_edit",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_shipping_methods_for_an_order_edit\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Gets a shopping list by ID.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShoppingList]
    def get_shopping_list_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_shopping_list_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Gets a shopping list by ID.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShoppingList, Integer, Hash)>] ShoppingList data, response status code and response headers
    def get_shopping_list_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_shopping_list_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_shopping_list_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_shopping_list_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/shopping-lists/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_shopping_list_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_shopping_list_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Gets a shopping list by Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShoppingList]
    def get_shopping_list_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_shopping_list_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Gets a shopping list by Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShoppingList, Integer, Hash)>] ShoppingList data, response status code and response headers
    def get_shopping_list_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_shopping_list_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_shopping_list_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_shopping_list_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/shopping-lists/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_shopping_list_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_shopping_list_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get State by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [State]
    def get_state_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_state_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get State by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(State, Integer, Hash)>] State data, response status code and response headers
    def get_state_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_state_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_state_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_state_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/states/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'State'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_state_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_state_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get State by Key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [State]
    def get_state_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_state_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get State by Key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(State, Integer, Hash)>] State data, response status code and response headers
    def get_state_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_state_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_state_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_state_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/states/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'State'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_state_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_state_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Store by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Store]
    def get_store_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_store_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Store by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Store, Integer, Hash)>] Store data, response status code and response headers
    def get_store_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_store_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_store_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_store_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/stores/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Store'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_store_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_store_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Store by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Store]
    def get_store_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_store_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get Store by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Store, Integer, Hash)>] Store data, response status code and response headers
    def get_store_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_store_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_store_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_store_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/stores/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Store'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_store_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_store_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieves the representation of a subscription by its id.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Subscription]
    def get_subscription_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_subscription_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Retrieves the representation of a subscription by its id.
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def get_subscription_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_subscription_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_subscription_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_subscription_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/subscriptions/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Subscription'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_subscription_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_subscription_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieves the representation of a subscription by its key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Subscription]
    def get_subscription_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_subscription_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Retrieves the representation of a subscription by its key.
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def get_subscription_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_subscription_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_subscription_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_subscription_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/subscriptions/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Subscription'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_subscription_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_subscription_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :fuzzy Whether to apply fuzzy search on the text to analyze.
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [Array<String>] :_search_keywords__a_z2___a_z2_ 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @return [String]
    def get_suggestion_keywords(project_key, opts = {})
      data, _status_code, _headers = get_suggestion_keywords_with_http_info(project_key, opts)
      data
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :fuzzy Whether to apply fuzzy search on the text to analyze.
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [Array<String>] :_search_keywords__a_z2___a_z2_ 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def get_suggestion_keywords_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_suggestion_keywords ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_suggestion_keywords"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.get_suggestion_keywords, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/product-projections/suggest'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'fuzzy'] = opts[:'fuzzy'] if !opts[:'fuzzy'].nil?
      query_params[:'staged'] = opts[:'staged'] if !opts[:'staged'].nil?
      query_params[:'/searchKeywords.[a-z]{2}(-[A-Z]{2})?/'] = @api_client.build_collection_param(opts[:'_search_keywords__a_z2___a_z2_'], :multi) if !opts[:'_search_keywords__a_z2___a_z2_'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_suggestion_keywords",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_suggestion_keywords\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get TaxCategory by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [TaxCategory]
    def get_tax_category_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_tax_category_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get TaxCategory by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(TaxCategory, Integer, Hash)>] TaxCategory data, response status code and response headers
    def get_tax_category_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_tax_category_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_tax_category_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_tax_category_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/tax-categories/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TaxCategory'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_tax_category_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_tax_category_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get TaxCategory by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [TaxCategory]
    def get_tax_category_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_tax_category_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get TaxCategory by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(TaxCategory, Integer, Hash)>] TaxCategory data, response status code and response headers
    def get_tax_category_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_tax_category_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_tax_category_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_tax_category_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/tax-categories/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TaxCategory'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_tax_category_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_tax_category_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Type by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Type]
    def get_type_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_type_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Type by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Type, Integer, Hash)>] Type data, response status code and response headers
    def get_type_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_type_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_type_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_type_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/types/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Type'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_type_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_type_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Type by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Type]
    def get_type_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_type_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get Type by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Type, Integer, Hash)>] Type data, response status code and response headers
    def get_type_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_type_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_type_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_type_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/types/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Type'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_type_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_type_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Zone by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Zone]
    def get_zone_by_id(project_key, id, opts = {})
      data, _status_code, _headers = get_zone_by_id_with_http_info(project_key, id, opts)
      data
    end

    # Get Zone by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Zone, Integer, Hash)>] Zone data, response status code and response headers
    def get_zone_by_id_with_http_info(project_key, id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_zone_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_zone_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.get_zone_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/zones/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Zone'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_zone_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_zone_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Zone by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Zone]
    def get_zone_by_key(project_key, key, opts = {})
      data, _status_code, _headers = get_zone_by_key_with_http_info(project_key, key, opts)
      data
    end

    # Get Zone by key
    # @param project_key [String] 
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Zone, Integer, Hash)>] Zone data, response status code and response headers
    def get_zone_by_key_with_http_info(project_key, key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_zone_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.get_zone_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.get_zone_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/zones/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Zone'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.get_zone_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_zone_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Execute a GraphQL query
    # @param project_key [String] 
    # @param graph_ql_request [GraphQLRequest] 
    # @param [Hash] opts the optional parameters
    # @return [GraphQLResponse]
    def graph_ql(project_key, graph_ql_request, opts = {})
      data, _status_code, _headers = graph_ql_with_http_info(project_key, graph_ql_request, opts)
      data
    end

    # Execute a GraphQL query
    # @param project_key [String] 
    # @param graph_ql_request [GraphQLRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GraphQLResponse, Integer, Hash)>] GraphQLResponse data, response status code and response headers
    def graph_ql_with_http_info(project_key, graph_ql_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.graph_ql ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.graph_ql"
      end
      # verify the required parameter 'graph_ql_request' is set
      if @api_client.config.client_side_validation && graph_ql_request.nil?
        fail ArgumentError, "Missing the required parameter 'graph_ql_request' when calling DefaultApi.graph_ql"
      end
      # resource path
      local_var_path = '/{projectKey}/graphql'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/graphql'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(graph_ql_request)

      # return_type
      return_type = opts[:debug_return_type] || 'GraphQLResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.graph_ql",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#graph_ql\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param key [String] 
    # @param my_cart_update [MyCartUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def p_ost_project_key_me_carts_keykey(project_key, key, my_cart_update, opts = {})
      p_ost_project_key_me_carts_keykey_with_http_info(project_key, key, my_cart_update, opts)
      nil
    end

    # @param project_key [String] 
    # @param key [String] 
    # @param my_cart_update [MyCartUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def p_ost_project_key_me_carts_keykey_with_http_info(project_key, key, my_cart_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.p_ost_project_key_me_carts_keykey ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.p_ost_project_key_me_carts_keykey"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.p_ost_project_key_me_carts_keykey"
      end
      # verify the required parameter 'my_cart_update' is set
      if @api_client.config.client_side_validation && my_cart_update.nil?
        fail ArgumentError, "Missing the required parameter 'my_cart_update' when calling DefaultApi.p_ost_project_key_me_carts_keykey"
      end
      # resource path
      local_var_path = '/{projectKey}/me/carts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_cart_update)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.p_ost_project_key_me_carts_keykey",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#p_ost_project_key_me_carts_keykey\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Updates a customer in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store's key. If the customer exists in the commercetools project but the stores field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param customer_update [CustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def post_customer_by_id_in_store(project_key, store_key, id, customer_update, opts = {})
      data, _status_code, _headers = post_customer_by_id_in_store_with_http_info(project_key, store_key, id, customer_update, opts)
      data
    end

    # Updates a customer in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store&#39;s key. If the customer exists in the commercetools project but the stores field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param customer_update [CustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def post_customer_by_id_in_store_with_http_info(project_key, store_key, id, customer_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.post_customer_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.post_customer_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.post_customer_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.post_customer_by_id_in_store"
      end
      # verify the required parameter 'customer_update' is set
      if @api_client.config.client_side_validation && customer_update.nil?
        fail ArgumentError, "Missing the required parameter 'customer_update' when calling DefaultApi.post_customer_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.post_customer_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#post_customer_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query api-clients
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ApiClientPagedQueryResponse]
    def query_api_clients(project_key, opts = {})
      data, _status_code, _headers = query_api_clients_with_http_info(project_key, opts)
      data
    end

    # Query api-clients
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ApiClientPagedQueryResponse, Integer, Hash)>] ApiClientPagedQueryResponse data, response status code and response headers
    def query_api_clients_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_api_clients ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_api_clients"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_api_clients, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/api-clients'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiClientPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_api_clients",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_api_clients\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query cart-discounts
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CartDiscountPagedQueryResponse]
    def query_cart_discounts(project_key, opts = {})
      data, _status_code, _headers = query_cart_discounts_with_http_info(project_key, opts)
      data
    end

    # Query cart-discounts
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CartDiscountPagedQueryResponse, Integer, Hash)>] CartDiscountPagedQueryResponse data, response status code and response headers
    def query_cart_discounts_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_cart_discounts ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_cart_discounts"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_cart_discounts, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/cart-discounts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CartDiscountPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_cart_discounts",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_cart_discounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query carts
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :customer_id 
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CartPagedQueryResponse]
    def query_carts(project_key, opts = {})
      data, _status_code, _headers = query_carts_with_http_info(project_key, opts)
      data
    end

    # Query carts
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :customer_id 
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CartPagedQueryResponse, Integer, Hash)>] CartPagedQueryResponse data, response status code and response headers
    def query_carts_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_carts ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_carts"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_carts, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/carts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'customerId'] = opts[:'customer_id'] if !opts[:'customer_id'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CartPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_carts",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_carts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Queries carts in a specific Store. The {storeKey} path parameter maps to a Store's key.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :customer_id 
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [OneOfCartPagedQueryResponseobject]
    def query_carts_in_store(project_key, store_key, opts = {})
      data, _status_code, _headers = query_carts_in_store_with_http_info(project_key, store_key, opts)
      data
    end

    # Queries carts in a specific Store. The {storeKey} path parameter maps to a Store&#39;s key.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :customer_id 
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(OneOfCartPagedQueryResponseobject, Integer, Hash)>] OneOfCartPagedQueryResponseobject data, response status code and response headers
    def query_carts_in_store_with_http_info(project_key, store_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_carts_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_carts_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.query_carts_in_store"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_carts_in_store, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'customerId'] = opts[:'customer_id'] if !opts[:'customer_id'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OneOfCartPagedQueryResponseobject'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_carts_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_carts_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query categories
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CategoryPagedQueryResponse]
    def query_categories(project_key, opts = {})
      data, _status_code, _headers = query_categories_with_http_info(project_key, opts)
      data
    end

    # Query categories
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CategoryPagedQueryResponse, Integer, Hash)>] CategoryPagedQueryResponse data, response status code and response headers
    def query_categories_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_categories ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_categories"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_categories, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/categories'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CategoryPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_categories",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_categories\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query channels
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ChannelPagedQueryResponse]
    def query_channels(project_key, opts = {})
      data, _status_code, _headers = query_channels_with_http_info(project_key, opts)
      data
    end

    # Query channels
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ChannelPagedQueryResponse, Integer, Hash)>] ChannelPagedQueryResponse data, response status code and response headers
    def query_channels_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_channels ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_channels"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_channels, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/channels'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ChannelPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_channels",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_channels\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # The query endpoint allows to retrieve custom objects in a specific container or all custom objects. For performance reasons, it is highly advisable to query only for custom objects in a container by using the container field in the where predicate.
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CustomObjectPagedQueryResponse]
    def query_custom_objects(project_key, opts = {})
      data, _status_code, _headers = query_custom_objects_with_http_info(project_key, opts)
      data
    end

    # The query endpoint allows to retrieve custom objects in a specific container or all custom objects. For performance reasons, it is highly advisable to query only for custom objects in a container by using the container field in the where predicate.
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CustomObjectPagedQueryResponse, Integer, Hash)>] CustomObjectPagedQueryResponse data, response status code and response headers
    def query_custom_objects_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_custom_objects ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_custom_objects"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_custom_objects, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/custom-objects'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomObjectPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_custom_objects",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_custom_objects\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query customer-groups
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CustomerGroupPagedQueryResponse]
    def query_customer_groups(project_key, opts = {})
      data, _status_code, _headers = query_customer_groups_with_http_info(project_key, opts)
      data
    end

    # Query customer-groups
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CustomerGroupPagedQueryResponse, Integer, Hash)>] CustomerGroupPagedQueryResponse data, response status code and response headers
    def query_customer_groups_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_customer_groups ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_customer_groups"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_customer_groups, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/customer-groups'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerGroupPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_customer_groups",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_customer_groups\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query customers
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CustomerPagedQueryResponse]
    def query_customers(project_key, opts = {})
      data, _status_code, _headers = query_customers_with_http_info(project_key, opts)
      data
    end

    # Query customers
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CustomerPagedQueryResponse, Integer, Hash)>] CustomerPagedQueryResponse data, response status code and response headers
    def query_customers_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_customers ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_customers"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_customers, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/customers'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_customers",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_customers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query customers
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CustomerPagedQueryResponse]
    def query_customers_in_store(project_key, store_key, opts = {})
      data, _status_code, _headers = query_customers_in_store_with_http_info(project_key, store_key, opts)
      data
    end

    # Query customers
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CustomerPagedQueryResponse, Integer, Hash)>] CustomerPagedQueryResponse data, response status code and response headers
    def query_customers_in_store_with_http_info(project_key, store_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_customers_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_customers_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.query_customers_in_store"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_customers_in_store, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_customers_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_customers_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query discount-codes
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [DiscountCodePagedQueryResponse]
    def query_discount_codes(project_key, opts = {})
      data, _status_code, _headers = query_discount_codes_with_http_info(project_key, opts)
      data
    end

    # Query discount-codes
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(DiscountCodePagedQueryResponse, Integer, Hash)>] DiscountCodePagedQueryResponse data, response status code and response headers
    def query_discount_codes_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_discount_codes ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_discount_codes"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_discount_codes, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/discount-codes'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DiscountCodePagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_discount_codes",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_discount_codes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query edits
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [OrderEditPagedQueryResponse]
    def query_edits(project_key, opts = {})
      data, _status_code, _headers = query_edits_with_http_info(project_key, opts)
      data
    end

    # Query edits
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(OrderEditPagedQueryResponse, Integer, Hash)>] OrderEditPagedQueryResponse data, response status code and response headers
    def query_edits_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_edits ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_edits"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_edits, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/orders/edits'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderEditPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_edits",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_edits\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query extensions
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ExtensionPagedQueryResponse]
    def query_extensions(project_key, opts = {})
      data, _status_code, _headers = query_extensions_with_http_info(project_key, opts)
      data
    end

    # Query extensions
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ExtensionPagedQueryResponse, Integer, Hash)>] ExtensionPagedQueryResponse data, response status code and response headers
    def query_extensions_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_extensions ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_extensions"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_extensions, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/extensions'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ExtensionPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_extensions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_extensions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query inventory
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [InventoryPagedQueryResponse]
    def query_inventory(project_key, opts = {})
      data, _status_code, _headers = query_inventory_with_http_info(project_key, opts)
      data
    end

    # Query inventory
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(InventoryPagedQueryResponse, Integer, Hash)>] InventoryPagedQueryResponse data, response status code and response headers
    def query_inventory_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_inventory ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_inventory"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_inventory, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/inventory'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'InventoryPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_inventory",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_inventory\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query messages
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [MessagePagedQueryResponse]
    def query_messages(project_key, opts = {})
      data, _status_code, _headers = query_messages_with_http_info(project_key, opts)
      data
    end

    # Query messages
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(MessagePagedQueryResponse, Integer, Hash)>] MessagePagedQueryResponse data, response status code and response headers
    def query_messages_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_messages ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_messages"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_messages, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/messages'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MessagePagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_messages",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_messages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query carts
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CartPagedQueryResponse]
    def query_my_carts(project_key, opts = {})
      data, _status_code, _headers = query_my_carts_with_http_info(project_key, opts)
      data
    end

    # Query carts
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CartPagedQueryResponse, Integer, Hash)>] CartPagedQueryResponse data, response status code and response headers
    def query_my_carts_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_my_carts ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_my_carts"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_my_carts, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/me/carts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CartPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_my_carts",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_my_carts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query carts
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [CartPagedQueryResponse]
    def query_my_carts_in_store(project_key, store_key, opts = {})
      data, _status_code, _headers = query_my_carts_in_store_with_http_info(project_key, store_key, opts)
      data
    end

    # Query carts
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(CartPagedQueryResponse, Integer, Hash)>] CartPagedQueryResponse data, response status code and response headers
    def query_my_carts_in_store_with_http_info(project_key, store_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_my_carts_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_my_carts_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.query_my_carts_in_store"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_my_carts_in_store, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/carts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CartPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_my_carts_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_my_carts_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query orders
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [OrderPagedQueryResponse]
    def query_my_orders(project_key, opts = {})
      data, _status_code, _headers = query_my_orders_with_http_info(project_key, opts)
      data
    end

    # Query orders
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(OrderPagedQueryResponse, Integer, Hash)>] OrderPagedQueryResponse data, response status code and response headers
    def query_my_orders_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_my_orders ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_my_orders"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_my_orders, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/me/orders'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_my_orders",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_my_orders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query orders
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [OrderPagedQueryResponse]
    def query_my_orders_in_store(project_key, store_key, opts = {})
      data, _status_code, _headers = query_my_orders_in_store_with_http_info(project_key, store_key, opts)
      data
    end

    # Query orders
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(OrderPagedQueryResponse, Integer, Hash)>] OrderPagedQueryResponse data, response status code and response headers
    def query_my_orders_in_store_with_http_info(project_key, store_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_my_orders_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_my_orders_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.query_my_orders_in_store"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_my_orders_in_store, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/orders'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_my_orders_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_my_orders_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query payments
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [MyPaymentPagedQueryResponse]
    def query_my_payments(project_key, opts = {})
      data, _status_code, _headers = query_my_payments_with_http_info(project_key, opts)
      data
    end

    # Query payments
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(MyPaymentPagedQueryResponse, Integer, Hash)>] MyPaymentPagedQueryResponse data, response status code and response headers
    def query_my_payments_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_my_payments ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_my_payments"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_my_payments, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/me/payments'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyPaymentPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_my_payments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_my_payments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query shopping-lists
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ShoppingListPagedQueryResponse]
    def query_my_shopping_lists(project_key, opts = {})
      data, _status_code, _headers = query_my_shopping_lists_with_http_info(project_key, opts)
      data
    end

    # Query shopping-lists
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ShoppingListPagedQueryResponse, Integer, Hash)>] ShoppingListPagedQueryResponse data, response status code and response headers
    def query_my_shopping_lists_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_my_shopping_lists ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_my_shopping_lists"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_my_shopping_lists, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/me/shopping-lists'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShoppingListPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_my_shopping_lists",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_my_shopping_lists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query orders
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [OrderPagedQueryResponse]
    def query_orders(project_key, opts = {})
      data, _status_code, _headers = query_orders_with_http_info(project_key, opts)
      data
    end

    # Query orders
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(OrderPagedQueryResponse, Integer, Hash)>] OrderPagedQueryResponse data, response status code and response headers
    def query_orders_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_orders ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_orders"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_orders, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/orders'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_orders",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_orders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Queries orders in a specific Store. The {storeKey} path parameter maps to a Store's key.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [OrderPagedQueryResponse]
    def query_orders_in_store(project_key, store_key, opts = {})
      data, _status_code, _headers = query_orders_in_store_with_http_info(project_key, store_key, opts)
      data
    end

    # Queries orders in a specific Store. The {storeKey} path parameter maps to a Store&#39;s key.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(OrderPagedQueryResponse, Integer, Hash)>] OrderPagedQueryResponse data, response status code and response headers
    def query_orders_in_store_with_http_info(project_key, store_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_orders_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_orders_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.query_orders_in_store"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_orders_in_store, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/orders'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrderPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_orders_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_orders_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query payments
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [PaymentPagedQueryResponse]
    def query_payments(project_key, opts = {})
      data, _status_code, _headers = query_payments_with_http_info(project_key, opts)
      data
    end

    # Query payments
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(PaymentPagedQueryResponse, Integer, Hash)>] PaymentPagedQueryResponse data, response status code and response headers
    def query_payments_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_payments ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_payments"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_payments, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/payments'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PaymentPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_payments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_payments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query product-discounts
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ProductDiscountPagedQueryResponse]
    def query_product_discounts(project_key, opts = {})
      data, _status_code, _headers = query_product_discounts_with_http_info(project_key, opts)
      data
    end

    # Query product-discounts
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ProductDiscountPagedQueryResponse, Integer, Hash)>] ProductDiscountPagedQueryResponse data, response status code and response headers
    def query_product_discounts_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_product_discounts ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_product_discounts"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_product_discounts, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/product-discounts'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductDiscountPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_product_discounts",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_product_discounts\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # You can use the product projections query endpoint to get the current or staged representations of Products. When used with an API client that has the view_published_products:{projectKey} scope, this endpoint only returns published (current) product projections.
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ProductProjectionPagedQueryResponse]
    def query_product_projections(project_key, opts = {})
      data, _status_code, _headers = query_product_projections_with_http_info(project_key, opts)
      data
    end

    # You can use the product projections query endpoint to get the current or staged representations of Products. When used with an API client that has the view_published_products:{projectKey} scope, this endpoint only returns published (current) product projections.
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ProductProjectionPagedQueryResponse, Integer, Hash)>] ProductProjectionPagedQueryResponse data, response status code and response headers
    def query_product_projections_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_product_projections ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_product_projections"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_product_projections, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/product-projections'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'staged'] = opts[:'staged'] if !opts[:'staged'].nil?
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductProjectionPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_product_projections",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_product_projections\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query product-types
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ProductTypePagedQueryResponse]
    def query_product_types(project_key, opts = {})
      data, _status_code, _headers = query_product_types_with_http_info(project_key, opts)
      data
    end

    # Query product-types
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ProductTypePagedQueryResponse, Integer, Hash)>] ProductTypePagedQueryResponse data, response status code and response headers
    def query_product_types_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_product_types ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_product_types"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_product_types, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/product-types'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductTypePagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_product_types",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_product_types\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # You can use the query endpoint to get the full representations of products. REMARK: We suggest to use the performance optimized search endpoint which has a bunch functionalities, the query API lacks like sorting on custom attributes, etc.
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ProductPagedQueryResponse]
    def query_products(project_key, opts = {})
      data, _status_code, _headers = query_products_with_http_info(project_key, opts)
      data
    end

    # You can use the query endpoint to get the full representations of products. REMARK: We suggest to use the performance optimized search endpoint which has a bunch functionalities, the query API lacks like sorting on custom attributes, etc.
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ProductPagedQueryResponse, Integer, Hash)>] ProductPagedQueryResponse data, response status code and response headers
    def query_products_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_products ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_products"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_products, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/products'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_products",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_products\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query reviews
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ReviewPagedQueryResponse]
    def query_reviews(project_key, opts = {})
      data, _status_code, _headers = query_reviews_with_http_info(project_key, opts)
      data
    end

    # Query reviews
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ReviewPagedQueryResponse, Integer, Hash)>] ReviewPagedQueryResponse data, response status code and response headers
    def query_reviews_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_reviews ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_reviews"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_reviews, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/reviews'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ReviewPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_reviews",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_reviews\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query shipping-methods
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ShippingMethodPagedQueryResponse]
    def query_shipping_methods(project_key, opts = {})
      data, _status_code, _headers = query_shipping_methods_with_http_info(project_key, opts)
      data
    end

    # Query shipping-methods
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ShippingMethodPagedQueryResponse, Integer, Hash)>] ShippingMethodPagedQueryResponse data, response status code and response headers
    def query_shipping_methods_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_shipping_methods ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_shipping_methods"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_shipping_methods, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/shipping-methods'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethodPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_shipping_methods",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_shipping_methods\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query shopping-lists
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ShoppingListPagedQueryResponse]
    def query_shopping_lists(project_key, opts = {})
      data, _status_code, _headers = query_shopping_lists_with_http_info(project_key, opts)
      data
    end

    # Query shopping-lists
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ShoppingListPagedQueryResponse, Integer, Hash)>] ShoppingListPagedQueryResponse data, response status code and response headers
    def query_shopping_lists_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_shopping_lists ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_shopping_lists"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_shopping_lists, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/shopping-lists'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ShoppingListPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_shopping_lists",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_shopping_lists\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query states
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [StatePagedQueryResponse]
    def query_states(project_key, opts = {})
      data, _status_code, _headers = query_states_with_http_info(project_key, opts)
      data
    end

    # Query states
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(StatePagedQueryResponse, Integer, Hash)>] StatePagedQueryResponse data, response status code and response headers
    def query_states_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_states ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_states"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_states, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/states'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'StatePagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_states",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_states\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query stores
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [StorePagedQueryResponse]
    def query_stores(project_key, opts = {})
      data, _status_code, _headers = query_stores_with_http_info(project_key, opts)
      data
    end

    # Query stores
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(StorePagedQueryResponse, Integer, Hash)>] StorePagedQueryResponse data, response status code and response headers
    def query_stores_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_stores ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_stores"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_stores, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/stores'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'StorePagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_stores",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_stores\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query subscriptions
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [SubscriptionPagedQueryResponse]
    def query_subscriptions(project_key, opts = {})
      data, _status_code, _headers = query_subscriptions_with_http_info(project_key, opts)
      data
    end

    # Query subscriptions
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(SubscriptionPagedQueryResponse, Integer, Hash)>] SubscriptionPagedQueryResponse data, response status code and response headers
    def query_subscriptions_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_subscriptions ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_subscriptions"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_subscriptions, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/subscriptions'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SubscriptionPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_subscriptions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_subscriptions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query tax-categories
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [TaxCategoryPagedQueryResponse]
    def query_tax_categories(project_key, opts = {})
      data, _status_code, _headers = query_tax_categories_with_http_info(project_key, opts)
      data
    end

    # Query tax-categories
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(TaxCategoryPagedQueryResponse, Integer, Hash)>] TaxCategoryPagedQueryResponse data, response status code and response headers
    def query_tax_categories_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_tax_categories ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_tax_categories"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_tax_categories, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/tax-categories'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TaxCategoryPagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_tax_categories",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_tax_categories\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query types
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [TypePagedQueryResponse]
    def query_types(project_key, opts = {})
      data, _status_code, _headers = query_types_with_http_info(project_key, opts)
      data
    end

    # Query types
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(TypePagedQueryResponse, Integer, Hash)>] TypePagedQueryResponse data, response status code and response headers
    def query_types_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_types ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_types"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_types, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/types'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TypePagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_types",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_types\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query zones
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [ZonePagedQueryResponse]
    def query_zones(project_key, opts = {})
      data, _status_code, _headers = query_zones_with_http_info(project_key, opts)
      data
    end

    # Query zones
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [Array<String>] :where If queries support ad-hoc filtering of resources through flexible predicates, they do so via the where query parameter that accepts a single (possibly compound) predicate to determine whether a specific resource representation should be included in the result.  The structure of predicates and the names of the fields follow the structure and naming of the fields in the documented response representation of the query results.  Examples of predicates:      // Compare a field&#39;s value to a given value     name &#x3D; \&quot;Peter\&quot;     age &lt; 42     age &gt; 42     age &lt;&#x3D; 42     age &gt;&#x3D; 42     age &lt;&gt; 42      // Combine any two conditional expressions in a logical conjunction / disjunction     name &#x3D; \&quot;Peter\&quot; and age &lt; 42     name &#x3D; \&quot;Peter\&quot; or age &lt; 42      // Negate any other conditional expression     not (name &#x3D; \&quot;Peter\&quot; and age &lt; 42)      // Check whether a field&#39;s value is or is not contained in     // a specified set of values.     age in (42, 43, 44)     age not in (42, 43, 44)      // Check whether an array contains all or any of a set of values     tags contains all (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)     tags contains any (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)      // Check whether an array is empty     tags is empty      // Check whether a field exists &amp; has a non-null value     name is defined     name is not defined      // Descend into nested objects     dog(age &lt; 7 and name &#x3D; \&quot;Beethoven\&quot;)      // Descend into nested arrays of objects     cities(zip &gt; 10000 and zip &lt; 20000)  A query endpoint usually restricts predicates to only be allowed on a specified subset of a resource representation&#39;s fields. The documentation of the endpoint will therefore list fields that can be used for constructing predicates.  If multiple predicates are specified via multiple where query parameters, the individual predicates are combined in a logical conjunction, just as if they had been specified in a single where query parameter and combined with and.  Note: The encoding of the predicates is UTF-8 and the predicate must be URL-encoded in the HTTP request.
    # @option opts [Array<String>] :_var___a_z_a_z0_9_ Predicate parameter values
    # @return [Array<(ZonePagedQueryResponse, Integer, Hash)>] ZonePagedQueryResponse data, response status code and response headers
    def query_zones_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.query_zones ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.query_zones"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.query_zones, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/zones'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'where'] = @api_client.build_collection_param(opts[:'where'], :multi) if !opts[:'where'].nil?
      query_params[:'/^var[.][a-zA-Z0-9]+$/'] = @api_client.build_collection_param(opts[:'_var___a_z_a_z0_9_'], :multi) if !opts[:'_var___a_z_a_z0_9_'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ZonePagedQueryResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.query_zones",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#query_zones\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param replica_cart_draft [ReplicaCartDraft] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def replicate_cart(project_key, replica_cart_draft, opts = {})
      replicate_cart_with_http_info(project_key, replica_cart_draft, opts)
      nil
    end

    # @param project_key [String] 
    # @param replica_cart_draft [ReplicaCartDraft] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def replicate_cart_with_http_info(project_key, replica_cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replicate_cart ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.replicate_cart"
      end
      # verify the required parameter 'replica_cart_draft' is set
      if @api_client.config.client_side_validation && replica_cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'replica_cart_draft' when calling DefaultApi.replicate_cart"
      end
      # resource path
      local_var_path = '/{projectKey}/carts/replicate'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(replica_cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.replicate_cart",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replicate_cart\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param store_key [String] 
    # @param replica_cart_draft [ReplicaCartDraft] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def replicate_cart_for_store(project_key, store_key, replica_cart_draft, opts = {})
      replicate_cart_for_store_with_http_info(project_key, store_key, replica_cart_draft, opts)
      nil
    end

    # @param project_key [String] 
    # @param store_key [String] 
    # @param replica_cart_draft [ReplicaCartDraft] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def replicate_cart_for_store_with_http_info(project_key, store_key, replica_cart_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replicate_cart_for_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.replicate_cart_for_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.replicate_cart_for_store"
      end
      # verify the required parameter 'replica_cart_draft' is set
      if @api_client.config.client_side_validation && replica_cart_draft.nil?
        fail ArgumentError, "Missing the required parameter 'replica_cart_draft' when calling DefaultApi.replicate_cart_for_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts/replicate'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(replica_cart_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.replicate_cart_for_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replicate_cart_for_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set a new password using a token.
    # @param project_key [String] 
    # @param customer_reset_password [CustomerResetPassword] 
    # @param [Hash] opts the optional parameters
    # @return [Customer]
    def reset_customers_password(project_key, customer_reset_password, opts = {})
      data, _status_code, _headers = reset_customers_password_with_http_info(project_key, customer_reset_password, opts)
      data
    end

    # Set a new password using a token.
    # @param project_key [String] 
    # @param customer_reset_password [CustomerResetPassword] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def reset_customers_password_with_http_info(project_key, customer_reset_password, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.reset_customers_password ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.reset_customers_password"
      end
      # verify the required parameter 'customer_reset_password' is set
      if @api_client.config.client_side_validation && customer_reset_password.nil?
        fail ArgumentError, "Missing the required parameter 'customer_reset_password' when calling DefaultApi.reset_customers_password"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/password/reset'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_reset_password)

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.reset_customers_password",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#reset_customers_password\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set a new password using a token.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_reset_password [CustomerResetPassword] 
    # @param [Hash] opts the optional parameters
    # @return [Customer]
    def reset_customers_password_in_store(project_key, store_key, customer_reset_password, opts = {})
      data, _status_code, _headers = reset_customers_password_in_store_with_http_info(project_key, store_key, customer_reset_password, opts)
      data
    end

    # Set a new password using a token.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_reset_password [CustomerResetPassword] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def reset_customers_password_in_store_with_http_info(project_key, store_key, customer_reset_password, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.reset_customers_password_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.reset_customers_password_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.reset_customers_password_in_store"
      end
      # verify the required parameter 'customer_reset_password' is set
      if @api_client.config.client_side_validation && customer_reset_password.nil?
        fail ArgumentError, "Missing the required parameter 'customer_reset_password' when calling DefaultApi.reset_customers_password_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/password/reset'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_reset_password)

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.reset_customers_password_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#reset_customers_password_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [MyCustomer]
    def reset_my_customers_password(project_key, opts = {})
      data, _status_code, _headers = reset_my_customers_password_with_http_info(project_key, opts)
      data
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MyCustomer, Integer, Hash)>] MyCustomer data, response status code and response headers
    def reset_my_customers_password_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.reset_my_customers_password ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.reset_my_customers_password"
      end
      # resource path
      local_var_path = '/{projectKey}/me/password/reset'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MyCustomer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.reset_my_customers_password",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#reset_my_customers_password\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Product Projection
    # @param project_key [String] 
    # @param mark_matching_variants [Boolean] if &#x60;markMatchingVariants&#x60; parameter is &#x60;true&#x60; those ProductVariants that match the search query have the additional field &#x60;isMatchingVariant&#x60; set to &#x60;true&#x60;. For the other variants in the same product projection this field is set to &#x60;false&#x60;.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :fuzzy Whether to apply fuzzy search on the text to analyze.
    # @option opts [Float] :fuzzy_level Provide explicitly the fuzzy level desired if fuzzy is enabled. This value can not be higher than the one chosen by the platform by default.
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [Array<String>] :filter 
    # @option opts [Array<String>] :filter_facets 
    # @option opts [Array<String>] :filter_query 
    # @option opts [Array<String>] :facet 
    # @option opts [Array<String>] :_text__a_z2___a_z2_ 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [ProductProjectionPagedSearchResponse]
    def search_products_by_get(project_key, mark_matching_variants, opts = {})
      data, _status_code, _headers = search_products_by_get_with_http_info(project_key, mark_matching_variants, opts)
      data
    end

    # Search Product Projection
    # @param project_key [String] 
    # @param mark_matching_variants [Boolean] if &#x60;markMatchingVariants&#x60; parameter is &#x60;true&#x60; those ProductVariants that match the search query have the additional field &#x60;isMatchingVariant&#x60; set to &#x60;true&#x60;. For the other variants in the same product projection this field is set to &#x60;false&#x60;.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :fuzzy Whether to apply fuzzy search on the text to analyze.
    # @option opts [Float] :fuzzy_level Provide explicitly the fuzzy level desired if fuzzy is enabled. This value can not be higher than the one chosen by the platform by default.
    # @option opts [Boolean] :staged Whether to query for the current or staged projections.
    # @option opts [Array<String>] :filter 
    # @option opts [Array<String>] :filter_facets 
    # @option opts [Array<String>] :filter_query 
    # @option opts [Array<String>] :facet 
    # @option opts [Array<String>] :_text__a_z2___a_z2_ 
    # @option opts [Array<String>] :sort A query endpoint that supports sorting does so through the sort query parameter. The provided value must be a valid sort expression. The default sort direction is ASC. The allowed sort paths are typically listed on the specific query endpoints.  Here are some x-annotation-examples of sort expressions:      name desc     dog.age asc  If multiple sort expressions are specified via multiple sort parameters, they are combined into a composed sort where the results are first sorted by the first expression, followed by equal values being sorted according to the second expression, and so on.  Note: The sorting is case sensitive.
    # @option opts [Integer] :limit Number of results returned
    # @option opts [Integer] :offset Number of results skipped
    # @option opts [Boolean] :with_total Calculate total number of results
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductProjectionPagedSearchResponse, Integer, Hash)>] ProductProjectionPagedSearchResponse data, response status code and response headers
    def search_products_by_get_with_http_info(project_key, mark_matching_variants, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.search_products_by_get ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.search_products_by_get"
      end
      # verify the required parameter 'mark_matching_variants' is set
      if @api_client.config.client_side_validation && mark_matching_variants.nil?
        fail ArgumentError, "Missing the required parameter 'mark_matching_variants' when calling DefaultApi.search_products_by_get"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DefaultApi.search_products_by_get, must be smaller than or equal to 500.'
      end

      # resource path
      local_var_path = '/{projectKey}/product-projections/search'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'markMatchingVariants'] = mark_matching_variants
      query_params[:'fuzzy'] = opts[:'fuzzy'] if !opts[:'fuzzy'].nil?
      query_params[:'fuzzyLevel'] = opts[:'fuzzy_level'] if !opts[:'fuzzy_level'].nil?
      query_params[:'staged'] = opts[:'staged'] if !opts[:'staged'].nil?
      query_params[:'filter'] = @api_client.build_collection_param(opts[:'filter'], :multi) if !opts[:'filter'].nil?
      query_params[:'filter.facets'] = @api_client.build_collection_param(opts[:'filter_facets'], :multi) if !opts[:'filter_facets'].nil?
      query_params[:'filter.query'] = @api_client.build_collection_param(opts[:'filter_query'], :multi) if !opts[:'filter_query'].nil?
      query_params[:'facet'] = @api_client.build_collection_param(opts[:'facet'], :multi) if !opts[:'facet'].nil?
      query_params[:'/text.[a-z]{2}(-[A-Z]{2})?/'] = @api_client.build_collection_param(opts[:'_text__a_z2___a_z2_'], :multi) if !opts[:'_text__a_z2___a_z2_'].nil?
      query_params[:'sort'] = @api_client.build_collection_param(opts[:'sort'], :multi) if !opts[:'sort'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'withTotal'] = opts[:'with_total'] if !opts[:'with_total'].nil?
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductProjectionPagedSearchResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.search_products_by_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#search_products_by_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Product Projection
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def search_products_by_post(project_key, opts = {})
      search_products_by_post_with_http_info(project_key, opts)
      nil
    end

    # Search Product Projection
    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def search_products_by_post_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.search_products_by_post ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.search_products_by_post"
      end
      # resource path
      local_var_path = '/{projectKey}/product-projections/search'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.search_products_by_post",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#search_products_by_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param my_customer_draft [MyCustomerDraft] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def signup_my_customer(project_key, my_customer_draft, opts = {})
      signup_my_customer_with_http_info(project_key, my_customer_draft, opts)
      nil
    end

    # @param project_key [String] 
    # @param my_customer_draft [MyCustomerDraft] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def signup_my_customer_with_http_info(project_key, my_customer_draft, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.signup_my_customer ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.signup_my_customer"
      end
      # verify the required parameter 'my_customer_draft' is set
      if @api_client.config.client_side_validation && my_customer_draft.nil?
        fail ArgumentError, "Missing the required parameter 'my_customer_draft' when calling DefaultApi.signup_my_customer"
      end
      # resource path
      local_var_path = '/{projectKey}/me/signup'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_customer_draft)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.signup_my_customer",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#signup_my_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Cart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param cart_update [CartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def update_cart_by_id(project_key, id, cart_update, opts = {})
      data, _status_code, _headers = update_cart_by_id_with_http_info(project_key, id, cart_update, opts)
      data
    end

    # Update Cart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param cart_update [CartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def update_cart_by_id_with_http_info(project_key, id, cart_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_cart_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_cart_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_cart_by_id"
      end
      # verify the required parameter 'cart_update' is set
      if @api_client.config.client_side_validation && cart_update.nil?
        fail ArgumentError, "Missing the required parameter 'cart_update' when calling DefaultApi.update_cart_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_cart_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_cart_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Updates a cart in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store's key. If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param cart_update [CartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def update_cart_by_id_in_store(project_key, store_key, id, cart_update, opts = {})
      data, _status_code, _headers = update_cart_by_id_in_store_with_http_info(project_key, store_key, id, cart_update, opts)
      data
    end

    # Updates a cart in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store&#39;s key. If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param cart_update [CartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def update_cart_by_id_in_store_with_http_info(project_key, store_key, id, cart_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_cart_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_cart_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.update_cart_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_cart_by_id_in_store"
      end
      # verify the required parameter 'cart_update' is set
      if @api_client.config.client_side_validation && cart_update.nil?
        fail ArgumentError, "Missing the required parameter 'cart_update' when calling DefaultApi.update_cart_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_cart_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_cart_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Cart by key
    # @param project_key [String] 
    # @param key [String] 
    # @param cart_update [CartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def update_cart_by_key(project_key, key, cart_update, opts = {})
      data, _status_code, _headers = update_cart_by_key_with_http_info(project_key, key, cart_update, opts)
      data
    end

    # Update Cart by key
    # @param project_key [String] 
    # @param key [String] 
    # @param cart_update [CartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def update_cart_by_key_with_http_info(project_key, key, cart_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_cart_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_cart_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_cart_by_key"
      end
      # verify the required parameter 'cart_update' is set
      if @api_client.config.client_side_validation && cart_update.nil?
        fail ArgumentError, "Missing the required parameter 'cart_update' when calling DefaultApi.update_cart_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/carts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_cart_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_cart_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Updates a cart in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store's key. If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param cart_update [CartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def update_cart_by_key_in_store(project_key, store_key, key, cart_update, opts = {})
      data, _status_code, _headers = update_cart_by_key_in_store_with_http_info(project_key, store_key, key, cart_update, opts)
      data
    end

    # Updates a cart in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store&#39;s key. If the cart exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param cart_update [CartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def update_cart_by_key_in_store_with_http_info(project_key, store_key, key, cart_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_cart_by_key_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_cart_by_key_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.update_cart_by_key_in_store"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_cart_by_key_in_store"
      end
      # verify the required parameter 'cart_update' is set
      if @api_client.config.client_side_validation && cart_update.nil?
        fail ArgumentError, "Missing the required parameter 'cart_update' when calling DefaultApi.update_cart_by_key_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/carts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_cart_by_key_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_cart_by_key_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update CartDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param cart_discount_update [CartDiscountUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CartDiscount]
    def update_cart_discount_by_id(project_key, id, cart_discount_update, opts = {})
      data, _status_code, _headers = update_cart_discount_by_id_with_http_info(project_key, id, cart_discount_update, opts)
      data
    end

    # Update CartDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param cart_discount_update [CartDiscountUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CartDiscount, Integer, Hash)>] CartDiscount data, response status code and response headers
    def update_cart_discount_by_id_with_http_info(project_key, id, cart_discount_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_cart_discount_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_cart_discount_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_cart_discount_by_id"
      end
      # verify the required parameter 'cart_discount_update' is set
      if @api_client.config.client_side_validation && cart_discount_update.nil?
        fail ArgumentError, "Missing the required parameter 'cart_discount_update' when calling DefaultApi.update_cart_discount_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/cart-discounts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_discount_update)

      # return_type
      return_type = opts[:debug_return_type] || 'CartDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_cart_discount_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_cart_discount_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update CartDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param cart_discount_update [CartDiscountUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CartDiscount]
    def update_cart_discount_by_key(project_key, key, cart_discount_update, opts = {})
      data, _status_code, _headers = update_cart_discount_by_key_with_http_info(project_key, key, cart_discount_update, opts)
      data
    end

    # Update CartDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param cart_discount_update [CartDiscountUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CartDiscount, Integer, Hash)>] CartDiscount data, response status code and response headers
    def update_cart_discount_by_key_with_http_info(project_key, key, cart_discount_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_cart_discount_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_cart_discount_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_cart_discount_by_key"
      end
      # verify the required parameter 'cart_discount_update' is set
      if @api_client.config.client_side_validation && cart_discount_update.nil?
        fail ArgumentError, "Missing the required parameter 'cart_discount_update' when calling DefaultApi.update_cart_discount_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/cart-discounts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(cart_discount_update)

      # return_type
      return_type = opts[:debug_return_type] || 'CartDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_cart_discount_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_cart_discount_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Category by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param category_update [CategoryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Category]
    def update_category_by_id(project_key, id, category_update, opts = {})
      data, _status_code, _headers = update_category_by_id_with_http_info(project_key, id, category_update, opts)
      data
    end

    # Update Category by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param category_update [CategoryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Category, Integer, Hash)>] Category data, response status code and response headers
    def update_category_by_id_with_http_info(project_key, id, category_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_category_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_category_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_category_by_id"
      end
      # verify the required parameter 'category_update' is set
      if @api_client.config.client_side_validation && category_update.nil?
        fail ArgumentError, "Missing the required parameter 'category_update' when calling DefaultApi.update_category_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/categories/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(category_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Category'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_category_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_category_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Category by key
    # @param project_key [String] 
    # @param key [String] 
    # @param category_update [CategoryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Category]
    def update_category_by_key(project_key, key, category_update, opts = {})
      data, _status_code, _headers = update_category_by_key_with_http_info(project_key, key, category_update, opts)
      data
    end

    # Update Category by key
    # @param project_key [String] 
    # @param key [String] 
    # @param category_update [CategoryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Category, Integer, Hash)>] Category data, response status code and response headers
    def update_category_by_key_with_http_info(project_key, key, category_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_category_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_category_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_category_by_key"
      end
      # verify the required parameter 'category_update' is set
      if @api_client.config.client_side_validation && category_update.nil?
        fail ArgumentError, "Missing the required parameter 'category_update' when calling DefaultApi.update_category_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/categories/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(category_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Category'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_category_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_category_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Channel by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param channel_update [ChannelUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Channel]
    def update_channel_by_id(project_key, id, channel_update, opts = {})
      data, _status_code, _headers = update_channel_by_id_with_http_info(project_key, id, channel_update, opts)
      data
    end

    # Update Channel by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param channel_update [ChannelUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Channel, Integer, Hash)>] Channel data, response status code and response headers
    def update_channel_by_id_with_http_info(project_key, id, channel_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_channel_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_channel_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_channel_by_id"
      end
      # verify the required parameter 'channel_update' is set
      if @api_client.config.client_side_validation && channel_update.nil?
        fail ArgumentError, "Missing the required parameter 'channel_update' when calling DefaultApi.update_channel_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/channels/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(channel_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Channel'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_channel_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_channel_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Customer by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param customer_update [CustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def update_customer_by_id(project_key, id, customer_update, opts = {})
      data, _status_code, _headers = update_customer_by_id_with_http_info(project_key, id, customer_update, opts)
      data
    end

    # Update Customer by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param customer_update [CustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def update_customer_by_id_with_http_info(project_key, id, customer_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_customer_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_customer_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_customer_by_id"
      end
      # verify the required parameter 'customer_update' is set
      if @api_client.config.client_side_validation && customer_update.nil?
        fail ArgumentError, "Missing the required parameter 'customer_update' when calling DefaultApi.update_customer_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_customer_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_customer_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Customer by key
    # @param project_key [String] 
    # @param key [String] 
    # @param customer_update [CustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def update_customer_by_key(project_key, key, customer_update, opts = {})
      data, _status_code, _headers = update_customer_by_key_with_http_info(project_key, key, customer_update, opts)
      data
    end

    # Update Customer by key
    # @param project_key [String] 
    # @param key [String] 
    # @param customer_update [CustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def update_customer_by_key_with_http_info(project_key, key, customer_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_customer_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_customer_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_customer_by_key"
      end
      # verify the required parameter 'customer_update' is set
      if @api_client.config.client_side_validation && customer_update.nil?
        fail ArgumentError, "Missing the required parameter 'customer_update' when calling DefaultApi.update_customer_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_customer_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_customer_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # If the customer exists in the commercetools project but the stores field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param customer_update [CustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Customer]
    def update_customer_by_key_in_store(project_key, store_key, key, customer_update, opts = {})
      data, _status_code, _headers = update_customer_by_key_in_store_with_http_info(project_key, store_key, key, customer_update, opts)
      data
    end

    # If the customer exists in the commercetools project but the stores field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param key [String] 
    # @param customer_update [CustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Customer, Integer, Hash)>] Customer data, response status code and response headers
    def update_customer_by_key_in_store_with_http_info(project_key, store_key, key, customer_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_customer_by_key_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_customer_by_key_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.update_customer_by_key_in_store"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_customer_by_key_in_store"
      end
      # verify the required parameter 'customer_update' is set
      if @api_client.config.client_side_validation && customer_update.nil?
        fail ArgumentError, "Missing the required parameter 'customer_update' when calling DefaultApi.update_customer_by_key_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Customer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_customer_by_key_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_customer_by_key_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update CustomerGroup by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param customer_group_update [CustomerGroupUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CustomerGroup]
    def update_customer_group_by_id(project_key, id, customer_group_update, opts = {})
      data, _status_code, _headers = update_customer_group_by_id_with_http_info(project_key, id, customer_group_update, opts)
      data
    end

    # Update CustomerGroup by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param customer_group_update [CustomerGroupUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomerGroup, Integer, Hash)>] CustomerGroup data, response status code and response headers
    def update_customer_group_by_id_with_http_info(project_key, id, customer_group_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_customer_group_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_customer_group_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_customer_group_by_id"
      end
      # verify the required parameter 'customer_group_update' is set
      if @api_client.config.client_side_validation && customer_group_update.nil?
        fail ArgumentError, "Missing the required parameter 'customer_group_update' when calling DefaultApi.update_customer_group_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/customer-groups/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_group_update)

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_customer_group_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_customer_group_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Updates a customer group by Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param customer_group_update [CustomerGroupUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [CustomerGroup]
    def update_customer_group_by_key(project_key, key, customer_group_update, opts = {})
      data, _status_code, _headers = update_customer_group_by_key_with_http_info(project_key, key, customer_group_update, opts)
      data
    end

    # Updates a customer group by Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param customer_group_update [CustomerGroupUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(CustomerGroup, Integer, Hash)>] CustomerGroup data, response status code and response headers
    def update_customer_group_by_key_with_http_info(project_key, key, customer_group_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_customer_group_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_customer_group_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_customer_group_by_key"
      end
      # verify the required parameter 'customer_group_update' is set
      if @api_client.config.client_side_validation && customer_group_update.nil?
        fail ArgumentError, "Missing the required parameter 'customer_group_update' when calling DefaultApi.update_customer_group_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/customer-groups/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_group_update)

      # return_type
      return_type = opts[:debug_return_type] || 'CustomerGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_customer_group_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_customer_group_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update DiscountCode by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param discount_code_update [DiscountCodeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [DiscountCode]
    def update_discount_code_by_id(project_key, id, discount_code_update, opts = {})
      data, _status_code, _headers = update_discount_code_by_id_with_http_info(project_key, id, discount_code_update, opts)
      data
    end

    # Update DiscountCode by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param discount_code_update [DiscountCodeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(DiscountCode, Integer, Hash)>] DiscountCode data, response status code and response headers
    def update_discount_code_by_id_with_http_info(project_key, id, discount_code_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_discount_code_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_discount_code_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_discount_code_by_id"
      end
      # verify the required parameter 'discount_code_update' is set
      if @api_client.config.client_side_validation && discount_code_update.nil?
        fail ArgumentError, "Missing the required parameter 'discount_code_update' when calling DefaultApi.update_discount_code_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/discount-codes/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(discount_code_update)

      # return_type
      return_type = opts[:debug_return_type] || 'DiscountCode'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_discount_code_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_discount_code_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Extension by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param extension_update [ExtensionUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Extension]
    def update_extension_by_id(project_key, id, extension_update, opts = {})
      data, _status_code, _headers = update_extension_by_id_with_http_info(project_key, id, extension_update, opts)
      data
    end

    # Update Extension by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param extension_update [ExtensionUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Extension, Integer, Hash)>] Extension data, response status code and response headers
    def update_extension_by_id_with_http_info(project_key, id, extension_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_extension_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_extension_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_extension_by_id"
      end
      # verify the required parameter 'extension_update' is set
      if @api_client.config.client_side_validation && extension_update.nil?
        fail ArgumentError, "Missing the required parameter 'extension_update' when calling DefaultApi.update_extension_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/extensions/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(extension_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Extension'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_extension_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_extension_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Extension by key
    # @param project_key [String] 
    # @param key [String] 
    # @param extension_update [ExtensionUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Extension]
    def update_extension_by_key(project_key, key, extension_update, opts = {})
      data, _status_code, _headers = update_extension_by_key_with_http_info(project_key, key, extension_update, opts)
      data
    end

    # Update Extension by key
    # @param project_key [String] 
    # @param key [String] 
    # @param extension_update [ExtensionUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Extension, Integer, Hash)>] Extension data, response status code and response headers
    def update_extension_by_key_with_http_info(project_key, key, extension_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_extension_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_extension_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_extension_by_key"
      end
      # verify the required parameter 'extension_update' is set
      if @api_client.config.client_side_validation && extension_update.nil?
        fail ArgumentError, "Missing the required parameter 'extension_update' when calling DefaultApi.update_extension_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/extensions/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(extension_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Extension'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_extension_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_extension_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update InventoryEntry by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param inventory_entry_update [InventoryEntryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [InventoryEntry]
    def update_inventory_entry_by_id(project_key, id, inventory_entry_update, opts = {})
      data, _status_code, _headers = update_inventory_entry_by_id_with_http_info(project_key, id, inventory_entry_update, opts)
      data
    end

    # Update InventoryEntry by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param inventory_entry_update [InventoryEntryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(InventoryEntry, Integer, Hash)>] InventoryEntry data, response status code and response headers
    def update_inventory_entry_by_id_with_http_info(project_key, id, inventory_entry_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_inventory_entry_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_inventory_entry_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_inventory_entry_by_id"
      end
      # verify the required parameter 'inventory_entry_update' is set
      if @api_client.config.client_side_validation && inventory_entry_update.nil?
        fail ArgumentError, "Missing the required parameter 'inventory_entry_update' when calling DefaultApi.update_inventory_entry_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/inventory/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(inventory_entry_update)

      # return_type
      return_type = opts[:debug_return_type] || 'InventoryEntry'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_inventory_entry_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_inventory_entry_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update MyCart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param my_cart_update [MyCartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyCart]
    def update_my_cart_by_id(project_key, id, my_cart_update, opts = {})
      data, _status_code, _headers = update_my_cart_by_id_with_http_info(project_key, id, my_cart_update, opts)
      data
    end

    # Update MyCart by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param my_cart_update [MyCartUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyCart, Integer, Hash)>] MyCart data, response status code and response headers
    def update_my_cart_by_id_with_http_info(project_key, id, my_cart_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_my_cart_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_my_cart_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_my_cart_by_id"
      end
      # verify the required parameter 'my_cart_update' is set
      if @api_client.config.client_side_validation && my_cart_update.nil?
        fail ArgumentError, "Missing the required parameter 'my_cart_update' when calling DefaultApi.update_my_cart_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_cart_update)

      # return_type
      return_type = opts[:debug_return_type] || 'MyCart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_my_cart_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_my_cart_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Cart by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param update [Update] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Cart]
    def update_my_cart_by_id_in_store(project_key, store_key, id, update, opts = {})
      data, _status_code, _headers = update_my_cart_by_id_in_store_with_http_info(project_key, store_key, id, update, opts)
      data
    end

    # Update Cart by ID
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param update [Update] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Cart, Integer, Hash)>] Cart data, response status code and response headers
    def update_my_cart_by_id_in_store_with_http_info(project_key, store_key, id, update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_my_cart_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_my_cart_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.update_my_cart_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_my_cart_by_id_in_store"
      end
      # verify the required parameter 'update' is set
      if @api_client.config.client_side_validation && update.nil?
        fail ArgumentError, "Missing the required parameter 'update' when calling DefaultApi.update_my_cart_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update)

      # return_type
      return_type = opts[:debug_return_type] || 'Cart'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_my_cart_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_my_cart_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update my customer
    # @param project_key [String] 
    # @param my_customer_update [MyCustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [MyCustomer]
    def update_my_customer(project_key, my_customer_update, opts = {})
      data, _status_code, _headers = update_my_customer_with_http_info(project_key, my_customer_update, opts)
      data
    end

    # Update my customer
    # @param project_key [String] 
    # @param my_customer_update [MyCustomerUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MyCustomer, Integer, Hash)>] MyCustomer data, response status code and response headers
    def update_my_customer_with_http_info(project_key, my_customer_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_my_customer ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_my_customer"
      end
      # verify the required parameter 'my_customer_update' is set
      if @api_client.config.client_side_validation && my_customer_update.nil?
        fail ArgumentError, "Missing the required parameter 'my_customer_update' when calling DefaultApi.update_my_customer"
      end
      # resource path
      local_var_path = '/{projectKey}/me'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_customer_update)

      # return_type
      return_type = opts[:debug_return_type] || 'MyCustomer'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_my_customer",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_my_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update MyPayment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param my_payment_update [MyPaymentUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyPayment]
    def update_my_payment_by_id(project_key, id, my_payment_update, opts = {})
      data, _status_code, _headers = update_my_payment_by_id_with_http_info(project_key, id, my_payment_update, opts)
      data
    end

    # Update MyPayment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param my_payment_update [MyPaymentUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyPayment, Integer, Hash)>] MyPayment data, response status code and response headers
    def update_my_payment_by_id_with_http_info(project_key, id, my_payment_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_my_payment_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_my_payment_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_my_payment_by_id"
      end
      # verify the required parameter 'my_payment_update' is set
      if @api_client.config.client_side_validation && my_payment_update.nil?
        fail ArgumentError, "Missing the required parameter 'my_payment_update' when calling DefaultApi.update_my_payment_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/payments/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_payment_update)

      # return_type
      return_type = opts[:debug_return_type] || 'MyPayment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_my_payment_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_my_payment_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update MyPayment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param my_payment_update [MyPaymentUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyPayment]
    def update_my_payment_by_key(project_key, key, my_payment_update, opts = {})
      data, _status_code, _headers = update_my_payment_by_key_with_http_info(project_key, key, my_payment_update, opts)
      data
    end

    # Update MyPayment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param my_payment_update [MyPaymentUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyPayment, Integer, Hash)>] MyPayment data, response status code and response headers
    def update_my_payment_by_key_with_http_info(project_key, key, my_payment_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_my_payment_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_my_payment_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_my_payment_by_key"
      end
      # verify the required parameter 'my_payment_update' is set
      if @api_client.config.client_side_validation && my_payment_update.nil?
        fail ArgumentError, "Missing the required parameter 'my_payment_update' when calling DefaultApi.update_my_payment_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/me/payments/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_payment_update)

      # return_type
      return_type = opts[:debug_return_type] || 'MyPayment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_my_payment_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_my_payment_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update MyShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param my_shopping_list_update [MyShoppingListUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyShoppingList]
    def update_my_shopping_list_by_id(project_key, id, my_shopping_list_update, opts = {})
      data, _status_code, _headers = update_my_shopping_list_by_id_with_http_info(project_key, id, my_shopping_list_update, opts)
      data
    end

    # Update MyShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param my_shopping_list_update [MyShoppingListUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyShoppingList, Integer, Hash)>] MyShoppingList data, response status code and response headers
    def update_my_shopping_list_by_id_with_http_info(project_key, id, my_shopping_list_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_my_shopping_list_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_my_shopping_list_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_my_shopping_list_by_id"
      end
      # verify the required parameter 'my_shopping_list_update' is set
      if @api_client.config.client_side_validation && my_shopping_list_update.nil?
        fail ArgumentError, "Missing the required parameter 'my_shopping_list_update' when calling DefaultApi.update_my_shopping_list_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/me/shopping-lists/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_shopping_list_update)

      # return_type
      return_type = opts[:debug_return_type] || 'MyShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_my_shopping_list_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_my_shopping_list_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update MyShoppingList by key
    # @param project_key [String] 
    # @param key [String] 
    # @param my_shopping_list_update [MyShoppingListUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [MyShoppingList]
    def update_my_shopping_list_by_key(project_key, key, my_shopping_list_update, opts = {})
      data, _status_code, _headers = update_my_shopping_list_by_key_with_http_info(project_key, key, my_shopping_list_update, opts)
      data
    end

    # Update MyShoppingList by key
    # @param project_key [String] 
    # @param key [String] 
    # @param my_shopping_list_update [MyShoppingListUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(MyShoppingList, Integer, Hash)>] MyShoppingList data, response status code and response headers
    def update_my_shopping_list_by_key_with_http_info(project_key, key, my_shopping_list_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_my_shopping_list_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_my_shopping_list_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_my_shopping_list_by_key"
      end
      # verify the required parameter 'my_shopping_list_update' is set
      if @api_client.config.client_side_validation && my_shopping_list_update.nil?
        fail ArgumentError, "Missing the required parameter 'my_shopping_list_update' when calling DefaultApi.update_my_shopping_list_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/me/shopping-lists/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(my_shopping_list_update)

      # return_type
      return_type = opts[:debug_return_type] || 'MyShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_my_shopping_list_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_my_shopping_list_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Order by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param order_update [OrderUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def update_order_by_id(project_key, id, order_update, opts = {})
      data, _status_code, _headers = update_order_by_id_with_http_info(project_key, id, order_update, opts)
      data
    end

    # Update Order by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param order_update [OrderUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def update_order_by_id_with_http_info(project_key, id, order_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_order_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_order_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_order_by_id"
      end
      # verify the required parameter 'order_update' is set
      if @api_client.config.client_side_validation && order_update.nil?
        fail ArgumentError, "Missing the required parameter 'order_update' when calling DefaultApi.update_order_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_order_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_order_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Updates an order in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store's key. If the order exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param order_update [OrderUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def update_order_by_id_in_store(project_key, store_key, id, order_update, opts = {})
      data, _status_code, _headers = update_order_by_id_in_store_with_http_info(project_key, store_key, id, order_update, opts)
      data
    end

    # Updates an order in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store&#39;s key. If the order exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param id [String] 
    # @param order_update [OrderUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def update_order_by_id_in_store_with_http_info(project_key, store_key, id, order_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_order_by_id_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_order_by_id_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.update_order_by_id_in_store"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_order_by_id_in_store"
      end
      # verify the required parameter 'order_update' is set
      if @api_client.config.client_side_validation && order_update.nil?
        fail ArgumentError, "Missing the required parameter 'order_update' when calling DefaultApi.update_order_by_id_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/orders/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_order_by_id_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_order_by_id_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Order by orderNumber
    # @param project_key [String] 
    # @param order_number [String] 
    # @param order_update [OrderUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def update_order_by_order_number(project_key, order_number, order_update, opts = {})
      data, _status_code, _headers = update_order_by_order_number_with_http_info(project_key, order_number, order_update, opts)
      data
    end

    # Update Order by orderNumber
    # @param project_key [String] 
    # @param order_number [String] 
    # @param order_update [OrderUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def update_order_by_order_number_with_http_info(project_key, order_number, order_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_order_by_order_number ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_order_by_order_number"
      end
      # verify the required parameter 'order_number' is set
      if @api_client.config.client_side_validation && order_number.nil?
        fail ArgumentError, "Missing the required parameter 'order_number' when calling DefaultApi.update_order_by_order_number"
      end
      # verify the required parameter 'order_update' is set
      if @api_client.config.client_side_validation && order_update.nil?
        fail ArgumentError, "Missing the required parameter 'order_update' when calling DefaultApi.update_order_by_order_number"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/order-number={orderNumber}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'orderNumber' + '}', CGI.escape(order_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_order_by_order_number",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_order_by_order_number\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Updates an order in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store's key. If the order exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error. In case the orderNumber does not match the regular expression [a-zA-Z0-9_-]+, it should be provided in URL-encoded format.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param order_number [String] 
    # @param order_update [OrderUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Order]
    def update_order_by_order_number_in_store(project_key, store_key, order_number, order_update, opts = {})
      data, _status_code, _headers = update_order_by_order_number_in_store_with_http_info(project_key, store_key, order_number, order_update, opts)
      data
    end

    # Updates an order in the store specified by {storeKey}. The {storeKey} path parameter maps to a Store&#39;s key. If the order exists in the commercetools project but does not have the store field, or the store field references a different store, this method returns a ResourceNotFound error. In case the orderNumber does not match the regular expression [a-zA-Z0-9_-]+, it should be provided in URL-encoded format.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param order_number [String] 
    # @param order_update [OrderUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Order, Integer, Hash)>] Order data, response status code and response headers
    def update_order_by_order_number_in_store_with_http_info(project_key, store_key, order_number, order_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_order_by_order_number_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_order_by_order_number_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.update_order_by_order_number_in_store"
      end
      # verify the required parameter 'order_number' is set
      if @api_client.config.client_side_validation && order_number.nil?
        fail ArgumentError, "Missing the required parameter 'order_number' when calling DefaultApi.update_order_by_order_number_in_store"
      end
      # verify the required parameter 'order_update' is set
      if @api_client.config.client_side_validation && order_update.nil?
        fail ArgumentError, "Missing the required parameter 'order_update' when calling DefaultApi.update_order_by_order_number_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s)).sub('{' + 'orderNumber' + '}', CGI.escape(order_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Order'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_order_by_order_number_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_order_by_order_number_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update OrderEdit by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param order_edit_update [OrderEditUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [OrderEdit]
    def update_order_edit_by_id(project_key, id, order_edit_update, opts = {})
      data, _status_code, _headers = update_order_edit_by_id_with_http_info(project_key, id, order_edit_update, opts)
      data
    end

    # Update OrderEdit by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param order_edit_update [OrderEditUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(OrderEdit, Integer, Hash)>] OrderEdit data, response status code and response headers
    def update_order_edit_by_id_with_http_info(project_key, id, order_edit_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_order_edit_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_order_edit_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_order_edit_by_id"
      end
      # verify the required parameter 'order_edit_update' is set
      if @api_client.config.client_side_validation && order_edit_update.nil?
        fail ArgumentError, "Missing the required parameter 'order_edit_update' when calling DefaultApi.update_order_edit_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/edits/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_edit_update)

      # return_type
      return_type = opts[:debug_return_type] || 'OrderEdit'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_order_edit_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_order_edit_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update OrderEdit by key
    # @param project_key [String] 
    # @param key [String] 
    # @param order_edit_update [OrderEditUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [OrderEdit]
    def update_order_edit_by_key(project_key, key, order_edit_update, opts = {})
      data, _status_code, _headers = update_order_edit_by_key_with_http_info(project_key, key, order_edit_update, opts)
      data
    end

    # Update OrderEdit by key
    # @param project_key [String] 
    # @param key [String] 
    # @param order_edit_update [OrderEditUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(OrderEdit, Integer, Hash)>] OrderEdit data, response status code and response headers
    def update_order_edit_by_key_with_http_info(project_key, key, order_edit_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_order_edit_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_order_edit_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_order_edit_by_key"
      end
      # verify the required parameter 'order_edit_update' is set
      if @api_client.config.client_side_validation && order_edit_update.nil?
        fail ArgumentError, "Missing the required parameter 'order_edit_update' when calling DefaultApi.update_order_edit_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/orders/edits/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_edit_update)

      # return_type
      return_type = opts[:debug_return_type] || 'OrderEdit'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_order_edit_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_order_edit_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Payment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param payment_update [PaymentUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Payment]
    def update_payment_by_id(project_key, id, payment_update, opts = {})
      data, _status_code, _headers = update_payment_by_id_with_http_info(project_key, id, payment_update, opts)
      data
    end

    # Update Payment by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param payment_update [PaymentUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Payment, Integer, Hash)>] Payment data, response status code and response headers
    def update_payment_by_id_with_http_info(project_key, id, payment_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_payment_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_payment_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_payment_by_id"
      end
      # verify the required parameter 'payment_update' is set
      if @api_client.config.client_side_validation && payment_update.nil?
        fail ArgumentError, "Missing the required parameter 'payment_update' when calling DefaultApi.update_payment_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/payments/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(payment_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Payment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_payment_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_payment_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Payment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param payment_update [PaymentUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Payment]
    def update_payment_by_key(project_key, key, payment_update, opts = {})
      data, _status_code, _headers = update_payment_by_key_with_http_info(project_key, key, payment_update, opts)
      data
    end

    # Update Payment by key
    # @param project_key [String] 
    # @param key [String] 
    # @param payment_update [PaymentUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Payment, Integer, Hash)>] Payment data, response status code and response headers
    def update_payment_by_key_with_http_info(project_key, key, payment_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_payment_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_payment_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_payment_by_key"
      end
      # verify the required parameter 'payment_update' is set
      if @api_client.config.client_side_validation && payment_update.nil?
        fail ArgumentError, "Missing the required parameter 'payment_update' when calling DefaultApi.update_payment_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/payments/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(payment_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Payment'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_payment_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_payment_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Product by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param product_update [ProductUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Product]
    def update_product_by_id(project_key, id, product_update, opts = {})
      data, _status_code, _headers = update_product_by_id_with_http_info(project_key, id, product_update, opts)
      data
    end

    # Update Product by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param product_update [ProductUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def update_product_by_id_with_http_info(project_key, id, product_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_product_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_product_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_product_by_id"
      end
      # verify the required parameter 'product_update' is set
      if @api_client.config.client_side_validation && product_update.nil?
        fail ArgumentError, "Missing the required parameter 'product_update' when calling DefaultApi.update_product_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/products/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Product'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_product_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_product_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Product by key
    # @param project_key [String] 
    # @param key [String] 
    # @param product_update [ProductUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Product]
    def update_product_by_key(project_key, key, product_update, opts = {})
      data, _status_code, _headers = update_product_by_key_with_http_info(project_key, key, product_update, opts)
      data
    end

    # Update Product by key
    # @param project_key [String] 
    # @param key [String] 
    # @param product_update [ProductUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :price_currency 
    # @option opts [String] :price_country 
    # @option opts [String] :price_customer_group 
    # @option opts [String] :price_channel 
    # @option opts [String] :locale_projection 
    # @option opts [String] :store_projection 
    # @option opts [Array<String>] :expand 
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def update_product_by_key_with_http_info(project_key, key, product_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_product_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_product_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_product_by_key"
      end
      # verify the required parameter 'product_update' is set
      if @api_client.config.client_side_validation && product_update.nil?
        fail ArgumentError, "Missing the required parameter 'product_update' when calling DefaultApi.update_product_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/products/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'priceCurrency'] = opts[:'price_currency'] if !opts[:'price_currency'].nil?
      query_params[:'priceCountry'] = opts[:'price_country'] if !opts[:'price_country'].nil?
      query_params[:'priceCustomerGroup'] = opts[:'price_customer_group'] if !opts[:'price_customer_group'].nil?
      query_params[:'priceChannel'] = opts[:'price_channel'] if !opts[:'price_channel'].nil?
      query_params[:'localeProjection'] = opts[:'locale_projection'] if !opts[:'locale_projection'].nil?
      query_params[:'storeProjection'] = opts[:'store_projection'] if !opts[:'store_projection'].nil?
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Product'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_product_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_product_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update ProductDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param product_discount_update [ProductDiscountUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductDiscount]
    def update_product_discount_by_id(project_key, id, product_discount_update, opts = {})
      data, _status_code, _headers = update_product_discount_by_id_with_http_info(project_key, id, product_discount_update, opts)
      data
    end

    # Update ProductDiscount by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param product_discount_update [ProductDiscountUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductDiscount, Integer, Hash)>] ProductDiscount data, response status code and response headers
    def update_product_discount_by_id_with_http_info(project_key, id, product_discount_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_product_discount_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_product_discount_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_product_discount_by_id"
      end
      # verify the required parameter 'product_discount_update' is set
      if @api_client.config.client_side_validation && product_discount_update.nil?
        fail ArgumentError, "Missing the required parameter 'product_discount_update' when calling DefaultApi.update_product_discount_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/product-discounts/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_discount_update)

      # return_type
      return_type = opts[:debug_return_type] || 'ProductDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_product_discount_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_product_discount_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update ProductDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param product_discount_update [ProductDiscountUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductDiscount]
    def update_product_discount_by_key(project_key, key, product_discount_update, opts = {})
      data, _status_code, _headers = update_product_discount_by_key_with_http_info(project_key, key, product_discount_update, opts)
      data
    end

    # Update ProductDiscount by key
    # @param project_key [String] 
    # @param key [String] 
    # @param product_discount_update [ProductDiscountUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductDiscount, Integer, Hash)>] ProductDiscount data, response status code and response headers
    def update_product_discount_by_key_with_http_info(project_key, key, product_discount_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_product_discount_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_product_discount_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_product_discount_by_key"
      end
      # verify the required parameter 'product_discount_update' is set
      if @api_client.config.client_side_validation && product_discount_update.nil?
        fail ArgumentError, "Missing the required parameter 'product_discount_update' when calling DefaultApi.update_product_discount_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/product-discounts/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_discount_update)

      # return_type
      return_type = opts[:debug_return_type] || 'ProductDiscount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_product_discount_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_product_discount_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update ProductType by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param product_type_update [ProductTypeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductType]
    def update_product_type_by_id(project_key, id, product_type_update, opts = {})
      data, _status_code, _headers = update_product_type_by_id_with_http_info(project_key, id, product_type_update, opts)
      data
    end

    # Update ProductType by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param product_type_update [ProductTypeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductType, Integer, Hash)>] ProductType data, response status code and response headers
    def update_product_type_by_id_with_http_info(project_key, id, product_type_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_product_type_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_product_type_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_product_type_by_id"
      end
      # verify the required parameter 'product_type_update' is set
      if @api_client.config.client_side_validation && product_type_update.nil?
        fail ArgumentError, "Missing the required parameter 'product_type_update' when calling DefaultApi.update_product_type_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/product-types/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_type_update)

      # return_type
      return_type = opts[:debug_return_type] || 'ProductType'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_product_type_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_product_type_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update ProductType by key
    # @param project_key [String] 
    # @param key [String] 
    # @param product_type_update [ProductTypeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ProductType]
    def update_product_type_by_key(project_key, key, product_type_update, opts = {})
      data, _status_code, _headers = update_product_type_by_key_with_http_info(project_key, key, product_type_update, opts)
      data
    end

    # Update ProductType by key
    # @param project_key [String] 
    # @param key [String] 
    # @param product_type_update [ProductTypeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ProductType, Integer, Hash)>] ProductType data, response status code and response headers
    def update_product_type_by_key_with_http_info(project_key, key, product_type_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_product_type_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_product_type_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_product_type_by_key"
      end
      # verify the required parameter 'product_type_update' is set
      if @api_client.config.client_side_validation && product_type_update.nil?
        fail ArgumentError, "Missing the required parameter 'product_type_update' when calling DefaultApi.update_product_type_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/product-types/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(product_type_update)

      # return_type
      return_type = opts[:debug_return_type] || 'ProductType'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_product_type_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_product_type_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update project
    # @param project_key [String] 
    # @param project_update [ProjectUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Project]
    def update_project_settings(project_key, project_update, opts = {})
      data, _status_code, _headers = update_project_settings_with_http_info(project_key, project_update, opts)
      data
    end

    # Update project
    # @param project_key [String] 
    # @param project_update [ProjectUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Project, Integer, Hash)>] Project data, response status code and response headers
    def update_project_settings_with_http_info(project_key, project_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_project_settings ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_project_settings"
      end
      # verify the required parameter 'project_update' is set
      if @api_client.config.client_side_validation && project_update.nil?
        fail ArgumentError, "Missing the required parameter 'project_update' when calling DefaultApi.update_project_settings"
      end
      # resource path
      local_var_path = '/{projectKey}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(project_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Project'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_project_settings",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_project_settings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Review by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param review_update [ReviewUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Review]
    def update_review_by_id(project_key, id, review_update, opts = {})
      data, _status_code, _headers = update_review_by_id_with_http_info(project_key, id, review_update, opts)
      data
    end

    # Update Review by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param review_update [ReviewUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Review, Integer, Hash)>] Review data, response status code and response headers
    def update_review_by_id_with_http_info(project_key, id, review_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_review_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_review_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_review_by_id"
      end
      # verify the required parameter 'review_update' is set
      if @api_client.config.client_side_validation && review_update.nil?
        fail ArgumentError, "Missing the required parameter 'review_update' when calling DefaultApi.update_review_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/reviews/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(review_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Review'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_review_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_review_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Review by key
    # @param project_key [String] 
    # @param key [String] 
    # @param review_update [ReviewUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Review]
    def update_review_by_key(project_key, key, review_update, opts = {})
      data, _status_code, _headers = update_review_by_key_with_http_info(project_key, key, review_update, opts)
      data
    end

    # Update Review by key
    # @param project_key [String] 
    # @param key [String] 
    # @param review_update [ReviewUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Review, Integer, Hash)>] Review data, response status code and response headers
    def update_review_by_key_with_http_info(project_key, key, review_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_review_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_review_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_review_by_key"
      end
      # verify the required parameter 'review_update' is set
      if @api_client.config.client_side_validation && review_update.nil?
        fail ArgumentError, "Missing the required parameter 'review_update' when calling DefaultApi.update_review_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/reviews/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(review_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Review'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_review_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_review_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update ShippingMethod by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param shipping_method_update [ShippingMethodUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethod]
    def update_shipping_method_by_id(project_key, id, shipping_method_update, opts = {})
      data, _status_code, _headers = update_shipping_method_by_id_with_http_info(project_key, id, shipping_method_update, opts)
      data
    end

    # Update ShippingMethod by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param shipping_method_update [ShippingMethodUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethod, Integer, Hash)>] ShippingMethod data, response status code and response headers
    def update_shipping_method_by_id_with_http_info(project_key, id, shipping_method_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_shipping_method_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_shipping_method_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_shipping_method_by_id"
      end
      # verify the required parameter 'shipping_method_update' is set
      if @api_client.config.client_side_validation && shipping_method_update.nil?
        fail ArgumentError, "Missing the required parameter 'shipping_method_update' when calling DefaultApi.update_shipping_method_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(shipping_method_update)

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethod'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_shipping_method_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_shipping_method_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update ShippingMethod by key
    # @param project_key [String] 
    # @param key [String] 
    # @param shipping_method_update [ShippingMethodUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShippingMethod]
    def update_shipping_method_by_key(project_key, key, shipping_method_update, opts = {})
      data, _status_code, _headers = update_shipping_method_by_key_with_http_info(project_key, key, shipping_method_update, opts)
      data
    end

    # Update ShippingMethod by key
    # @param project_key [String] 
    # @param key [String] 
    # @param shipping_method_update [ShippingMethodUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShippingMethod, Integer, Hash)>] ShippingMethod data, response status code and response headers
    def update_shipping_method_by_key_with_http_info(project_key, key, shipping_method_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_shipping_method_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_shipping_method_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_shipping_method_by_key"
      end
      # verify the required parameter 'shipping_method_update' is set
      if @api_client.config.client_side_validation && shipping_method_update.nil?
        fail ArgumentError, "Missing the required parameter 'shipping_method_update' when calling DefaultApi.update_shipping_method_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/shipping-methods/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(shipping_method_update)

      # return_type
      return_type = opts[:debug_return_type] || 'ShippingMethod'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_shipping_method_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_shipping_method_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update ShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param shopping_list_update [ShoppingListUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShoppingList]
    def update_shopping_list_by_id(project_key, id, shopping_list_update, opts = {})
      data, _status_code, _headers = update_shopping_list_by_id_with_http_info(project_key, id, shopping_list_update, opts)
      data
    end

    # Update ShoppingList by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param shopping_list_update [ShoppingListUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShoppingList, Integer, Hash)>] ShoppingList data, response status code and response headers
    def update_shopping_list_by_id_with_http_info(project_key, id, shopping_list_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_shopping_list_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_shopping_list_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_shopping_list_by_id"
      end
      # verify the required parameter 'shopping_list_update' is set
      if @api_client.config.client_side_validation && shopping_list_update.nil?
        fail ArgumentError, "Missing the required parameter 'shopping_list_update' when calling DefaultApi.update_shopping_list_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/shopping-lists/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(shopping_list_update)

      # return_type
      return_type = opts[:debug_return_type] || 'ShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_shopping_list_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_shopping_list_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a shopping list found by its Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param shopping_list_update [ShoppingListUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [ShoppingList]
    def update_shopping_list_by_key(project_key, key, shopping_list_update, opts = {})
      data, _status_code, _headers = update_shopping_list_by_key_with_http_info(project_key, key, shopping_list_update, opts)
      data
    end

    # Update a shopping list found by its Key.
    # @param project_key [String] 
    # @param key [String] 
    # @param shopping_list_update [ShoppingListUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(ShoppingList, Integer, Hash)>] ShoppingList data, response status code and response headers
    def update_shopping_list_by_key_with_http_info(project_key, key, shopping_list_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_shopping_list_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_shopping_list_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_shopping_list_by_key"
      end
      # verify the required parameter 'shopping_list_update' is set
      if @api_client.config.client_side_validation && shopping_list_update.nil?
        fail ArgumentError, "Missing the required parameter 'shopping_list_update' when calling DefaultApi.update_shopping_list_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/shopping-lists/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(shopping_list_update)

      # return_type
      return_type = opts[:debug_return_type] || 'ShoppingList'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_shopping_list_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_shopping_list_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update State by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param state_update [StateUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [State]
    def update_state_by_id(project_key, id, state_update, opts = {})
      data, _status_code, _headers = update_state_by_id_with_http_info(project_key, id, state_update, opts)
      data
    end

    # Update State by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param state_update [StateUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(State, Integer, Hash)>] State data, response status code and response headers
    def update_state_by_id_with_http_info(project_key, id, state_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_state_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_state_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_state_by_id"
      end
      # verify the required parameter 'state_update' is set
      if @api_client.config.client_side_validation && state_update.nil?
        fail ArgumentError, "Missing the required parameter 'state_update' when calling DefaultApi.update_state_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/states/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(state_update)

      # return_type
      return_type = opts[:debug_return_type] || 'State'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_state_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_state_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update State by Key
    # @param project_key [String] 
    # @param key [String] 
    # @param state_update [StateUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [State]
    def update_state_by_key(project_key, key, state_update, opts = {})
      data, _status_code, _headers = update_state_by_key_with_http_info(project_key, key, state_update, opts)
      data
    end

    # Update State by Key
    # @param project_key [String] 
    # @param key [String] 
    # @param state_update [StateUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(State, Integer, Hash)>] State data, response status code and response headers
    def update_state_by_key_with_http_info(project_key, key, state_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_state_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_state_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_state_by_key"
      end
      # verify the required parameter 'state_update' is set
      if @api_client.config.client_side_validation && state_update.nil?
        fail ArgumentError, "Missing the required parameter 'state_update' when calling DefaultApi.update_state_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/states/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(state_update)

      # return_type
      return_type = opts[:debug_return_type] || 'State'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_state_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_state_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Store by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param store_update [StoreUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Store]
    def update_store_by_id(project_key, id, store_update, opts = {})
      data, _status_code, _headers = update_store_by_id_with_http_info(project_key, id, store_update, opts)
      data
    end

    # Update Store by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param store_update [StoreUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Store, Integer, Hash)>] Store data, response status code and response headers
    def update_store_by_id_with_http_info(project_key, id, store_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_store_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_store_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_store_by_id"
      end
      # verify the required parameter 'store_update' is set
      if @api_client.config.client_side_validation && store_update.nil?
        fail ArgumentError, "Missing the required parameter 'store_update' when calling DefaultApi.update_store_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/stores/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(store_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Store'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_store_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_store_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Store by key
    # @param project_key [String] 
    # @param key [String] 
    # @param store_update [StoreUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Store]
    def update_store_by_key(project_key, key, store_update, opts = {})
      data, _status_code, _headers = update_store_by_key_with_http_info(project_key, key, store_update, opts)
      data
    end

    # Update Store by key
    # @param project_key [String] 
    # @param key [String] 
    # @param store_update [StoreUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Store, Integer, Hash)>] Store data, response status code and response headers
    def update_store_by_key_with_http_info(project_key, key, store_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_store_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_store_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_store_by_key"
      end
      # verify the required parameter 'store_update' is set
      if @api_client.config.client_side_validation && store_update.nil?
        fail ArgumentError, "Missing the required parameter 'store_update' when calling DefaultApi.update_store_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/stores/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(store_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Store'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_store_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_store_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Subscription by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param subscription_update [SubscriptionUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Subscription]
    def update_subscription_by_id(project_key, id, subscription_update, opts = {})
      data, _status_code, _headers = update_subscription_by_id_with_http_info(project_key, id, subscription_update, opts)
      data
    end

    # Update Subscription by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param subscription_update [SubscriptionUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def update_subscription_by_id_with_http_info(project_key, id, subscription_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_subscription_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_subscription_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_subscription_by_id"
      end
      # verify the required parameter 'subscription_update' is set
      if @api_client.config.client_side_validation && subscription_update.nil?
        fail ArgumentError, "Missing the required parameter 'subscription_update' when calling DefaultApi.update_subscription_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/subscriptions/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(subscription_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Subscription'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_subscription_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_subscription_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Subscription by key
    # @param project_key [String] 
    # @param key [String] 
    # @param subscription_update [SubscriptionUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Subscription]
    def update_subscription_by_key(project_key, key, subscription_update, opts = {})
      data, _status_code, _headers = update_subscription_by_key_with_http_info(project_key, key, subscription_update, opts)
      data
    end

    # Update Subscription by key
    # @param project_key [String] 
    # @param key [String] 
    # @param subscription_update [SubscriptionUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Subscription, Integer, Hash)>] Subscription data, response status code and response headers
    def update_subscription_by_key_with_http_info(project_key, key, subscription_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_subscription_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_subscription_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_subscription_by_key"
      end
      # verify the required parameter 'subscription_update' is set
      if @api_client.config.client_side_validation && subscription_update.nil?
        fail ArgumentError, "Missing the required parameter 'subscription_update' when calling DefaultApi.update_subscription_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/subscriptions/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(subscription_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Subscription'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_subscription_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_subscription_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update TaxCategory by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param tax_category_update [TaxCategoryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [TaxCategory]
    def update_tax_category_by_id(project_key, id, tax_category_update, opts = {})
      data, _status_code, _headers = update_tax_category_by_id_with_http_info(project_key, id, tax_category_update, opts)
      data
    end

    # Update TaxCategory by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param tax_category_update [TaxCategoryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(TaxCategory, Integer, Hash)>] TaxCategory data, response status code and response headers
    def update_tax_category_by_id_with_http_info(project_key, id, tax_category_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_tax_category_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_tax_category_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_tax_category_by_id"
      end
      # verify the required parameter 'tax_category_update' is set
      if @api_client.config.client_side_validation && tax_category_update.nil?
        fail ArgumentError, "Missing the required parameter 'tax_category_update' when calling DefaultApi.update_tax_category_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/tax-categories/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(tax_category_update)

      # return_type
      return_type = opts[:debug_return_type] || 'TaxCategory'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_tax_category_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_tax_category_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update TaxCategory by key
    # @param project_key [String] 
    # @param key [String] 
    # @param tax_category_update [TaxCategoryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [TaxCategory]
    def update_tax_category_by_key(project_key, key, tax_category_update, opts = {})
      data, _status_code, _headers = update_tax_category_by_key_with_http_info(project_key, key, tax_category_update, opts)
      data
    end

    # Update TaxCategory by key
    # @param project_key [String] 
    # @param key [String] 
    # @param tax_category_update [TaxCategoryUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(TaxCategory, Integer, Hash)>] TaxCategory data, response status code and response headers
    def update_tax_category_by_key_with_http_info(project_key, key, tax_category_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_tax_category_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_tax_category_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_tax_category_by_key"
      end
      # verify the required parameter 'tax_category_update' is set
      if @api_client.config.client_side_validation && tax_category_update.nil?
        fail ArgumentError, "Missing the required parameter 'tax_category_update' when calling DefaultApi.update_tax_category_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/tax-categories/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(tax_category_update)

      # return_type
      return_type = opts[:debug_return_type] || 'TaxCategory'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_tax_category_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_tax_category_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Type by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param type_update [TypeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Type]
    def update_type_by_id(project_key, id, type_update, opts = {})
      data, _status_code, _headers = update_type_by_id_with_http_info(project_key, id, type_update, opts)
      data
    end

    # Update Type by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param type_update [TypeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Type, Integer, Hash)>] Type data, response status code and response headers
    def update_type_by_id_with_http_info(project_key, id, type_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_type_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_type_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_type_by_id"
      end
      # verify the required parameter 'type_update' is set
      if @api_client.config.client_side_validation && type_update.nil?
        fail ArgumentError, "Missing the required parameter 'type_update' when calling DefaultApi.update_type_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/types/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(type_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Type'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_type_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_type_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Type by key
    # @param project_key [String] 
    # @param key [String] 
    # @param type_update [TypeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Type]
    def update_type_by_key(project_key, key, type_update, opts = {})
      data, _status_code, _headers = update_type_by_key_with_http_info(project_key, key, type_update, opts)
      data
    end

    # Update Type by key
    # @param project_key [String] 
    # @param key [String] 
    # @param type_update [TypeUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Type, Integer, Hash)>] Type data, response status code and response headers
    def update_type_by_key_with_http_info(project_key, key, type_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_type_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_type_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_type_by_key"
      end
      # verify the required parameter 'type_update' is set
      if @api_client.config.client_side_validation && type_update.nil?
        fail ArgumentError, "Missing the required parameter 'type_update' when calling DefaultApi.update_type_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/types/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(type_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Type'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_type_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_type_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Zone by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param zone_update [ZoneUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Zone]
    def update_zone_by_id(project_key, id, zone_update, opts = {})
      data, _status_code, _headers = update_zone_by_id_with_http_info(project_key, id, zone_update, opts)
      data
    end

    # Update Zone by ID
    # @param project_key [String] 
    # @param id [String] 
    # @param zone_update [ZoneUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Zone, Integer, Hash)>] Zone data, response status code and response headers
    def update_zone_by_id_with_http_info(project_key, id, zone_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_zone_by_id ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_zone_by_id"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.update_zone_by_id"
      end
      # verify the required parameter 'zone_update' is set
      if @api_client.config.client_side_validation && zone_update.nil?
        fail ArgumentError, "Missing the required parameter 'zone_update' when calling DefaultApi.update_zone_by_id"
      end
      # resource path
      local_var_path = '/{projectKey}/zones/{ID}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(zone_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Zone'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_zone_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_zone_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Zone by key
    # @param project_key [String] 
    # @param key [String] 
    # @param zone_update [ZoneUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Zone]
    def update_zone_by_key(project_key, key, zone_update, opts = {})
      data, _status_code, _headers = update_zone_by_key_with_http_info(project_key, key, zone_update, opts)
      data
    end

    # Update Zone by key
    # @param project_key [String] 
    # @param key [String] 
    # @param zone_update [ZoneUpdate] 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :expand 
    # @return [Array<(Zone, Integer, Hash)>] Zone data, response status code and response headers
    def update_zone_by_key_with_http_info(project_key, key, zone_update, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.update_zone_by_key ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.update_zone_by_key"
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DefaultApi.update_zone_by_key"
      end
      # verify the required parameter 'zone_update' is set
      if @api_client.config.client_side_validation && zone_update.nil?
        fail ArgumentError, "Missing the required parameter 'zone_update' when calling DefaultApi.update_zone_by_key"
      end
      # resource path
      local_var_path = '/{projectKey}/zones/key={key}'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'expand'] = @api_client.build_collection_param(opts[:'expand'], :multi) if !opts[:'expand'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(zone_update)

      # return_type
      return_type = opts[:debug_return_type] || 'Zone'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.update_zone_by_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#update_zone_by_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Uploads a binary image file to a given product variant. The supported image formats are JPEG, PNG and GIF.
    # @param project_key [String] 
    # @param id [String] 
    # @param body [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :filename 
    # @option opts [Float] :variant 
    # @option opts [String] :sku 
    # @option opts [Boolean] :staged 
    # @return [Product]
    def upload_a_product_image(project_key, id, body, opts = {})
      data, _status_code, _headers = upload_a_product_image_with_http_info(project_key, id, body, opts)
      data
    end

    # Uploads a binary image file to a given product variant. The supported image formats are JPEG, PNG and GIF.
    # @param project_key [String] 
    # @param id [String] 
    # @param body [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :filename 
    # @option opts [Float] :variant 
    # @option opts [String] :sku 
    # @option opts [Boolean] :staged 
    # @return [Array<(Product, Integer, Hash)>] Product data, response status code and response headers
    def upload_a_product_image_with_http_info(project_key, id, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.upload_a_product_image ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.upload_a_product_image"
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling DefaultApi.upload_a_product_image"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.upload_a_product_image"
      end
      # resource path
      local_var_path = '/{projectKey}/products/{ID}/images'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'ID' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'filename'] = opts[:'filename'] if !opts[:'filename'].nil?
      query_params[:'variant'] = opts[:'variant'] if !opts[:'variant'].nil?
      query_params[:'sku'] = opts[:'sku'] if !opts[:'sku'].nil?
      query_params[:'staged'] = opts[:'staged'] if !opts[:'staged'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'Product'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.upload_a_product_image",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#upload_a_product_image\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Verifies customer's email using a token.
    # @param project_key [String] 
    # @param customer_email_verify [CustomerEmailVerify] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def verifies_customers_email_(project_key, customer_email_verify, opts = {})
      verifies_customers_email__with_http_info(project_key, customer_email_verify, opts)
      nil
    end

    # Verifies customer&#39;s email using a token.
    # @param project_key [String] 
    # @param customer_email_verify [CustomerEmailVerify] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def verifies_customers_email__with_http_info(project_key, customer_email_verify, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.verifies_customers_email_ ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.verifies_customers_email_"
      end
      # verify the required parameter 'customer_email_verify' is set
      if @api_client.config.client_side_validation && customer_email_verify.nil?
        fail ArgumentError, "Missing the required parameter 'customer_email_verify' when calling DefaultApi.verifies_customers_email_"
      end
      # resource path
      local_var_path = '/{projectKey}/customers/email/confirm'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_email_verify)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.verifies_customers_email_",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#verifies_customers_email_\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Verifies customer's email using a token.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_email_verify [CustomerEmailVerify] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def verify_customers_email_in_store(project_key, store_key, customer_email_verify, opts = {})
      verify_customers_email_in_store_with_http_info(project_key, store_key, customer_email_verify, opts)
      nil
    end

    # Verifies customer&#39;s email using a token.
    # @param project_key [String] 
    # @param store_key [String] 
    # @param customer_email_verify [CustomerEmailVerify] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def verify_customers_email_in_store_with_http_info(project_key, store_key, customer_email_verify, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.verify_customers_email_in_store ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.verify_customers_email_in_store"
      end
      # verify the required parameter 'store_key' is set
      if @api_client.config.client_side_validation && store_key.nil?
        fail ArgumentError, "Missing the required parameter 'store_key' when calling DefaultApi.verify_customers_email_in_store"
      end
      # verify the required parameter 'customer_email_verify' is set
      if @api_client.config.client_side_validation && customer_email_verify.nil?
        fail ArgumentError, "Missing the required parameter 'customer_email_verify' when calling DefaultApi.verify_customers_email_in_store"
      end
      # resource path
      local_var_path = '/{projectKey}/in-store/key={storeKey}/customers/email/confirm'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s)).sub('{' + 'storeKey' + '}', CGI.escape(store_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(customer_email_verify)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.verify_customers_email_in_store",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#verify_customers_email_in_store\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def verify_my_customers_email(project_key, opts = {})
      verify_my_customers_email_with_http_info(project_key, opts)
      nil
    end

    # @param project_key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def verify_my_customers_email_with_http_info(project_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.verify_my_customers_email ...'
      end
      # verify the required parameter 'project_key' is set
      if @api_client.config.client_side_validation && project_key.nil?
        fail ArgumentError, "Missing the required parameter 'project_key' when calling DefaultApi.verify_my_customers_email"
      end
      # resource path
      local_var_path = '/{projectKey}/me/email/confirm'.sub('{' + 'projectKey' + '}', CGI.escape(project_key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth_2_0']

      new_options = opts.merge(
        :operation => :"DefaultApi.verify_my_customers_email",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#verify_my_customers_email\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
